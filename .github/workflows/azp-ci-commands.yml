name: Azure Pipelines CI (Xcode/VS Projects)

# This workflow handles /ci-azp commands in PR comments and descriptions
# It parses commands and triggers Azure Pipelines builds for Xcode and Visual Studio projects
# Note: CMake builds use /ci-cmake commands and are handled by cmake-ci.yml

on:
  # Trigger on PR comments containing /ci-azp commands
  issue_comment:
    types: [created]

  # Trigger on PR open/edit to parse commands from PR body
  pull_request:
    types: [opened, edited, synchronize]

  # Allow manual triggering with parameters
  workflow_dispatch:
    inputs:
      projects:
        description: 'Projects to build (comma-separated, or "all")'
        required: false
        default: 'IPlugEffect'
        type: string
      platforms:
        description: 'Platforms to build (mac,win,ios,web)'
        required: false
        default: 'mac,win'
        type: string
      formats:
        description: 'Plugin formats (app,vst3,clap,auv2)'
        required: false
        default: 'app,vst3,clap'
        type: string
      graphics:
        description: 'Graphics backends (nanovg,skia,both)'
        required: false
        default: 'nanovg'
        type: string
      test:
        description: 'Run plugin validation tests'
        required: false
        default: false
        type: boolean
      pr_number:
        description: 'PR number (for context)'
        required: false
        type: string

env:
  # Default configuration
  DEFAULT_PROJECTS: 'IPlugEffect'
  DEFAULT_PLATFORMS: 'mac,win'
  DEFAULT_FORMATS: 'app,vst3,clap,auv2'
  DEFAULT_GRAPHICS: 'nanovg'

jobs:
  # Parse CI commands from PR body or comment
  parse-commands:
    name: Parse CI Commands
    runs-on: ubuntu-latest
    # Only run on PR comments that contain /ci-azp, or PR events, or workflow_dispatch
    if: |
      github.event_name == 'workflow_dispatch' ||
      github.event_name == 'pull_request' ||
      (github.event_name == 'issue_comment' &&
       github.event.issue.pull_request &&
       contains(github.event.comment.body, '/ci-azp'))
    outputs:
      should_build: ${{ steps.parse.outputs.should_build }}
      skip: ${{ steps.parse.outputs.skip }}
      projects: ${{ steps.parse.outputs.projects }}
      platforms: ${{ steps.parse.outputs.platforms }}
      formats: ${{ steps.parse.outputs.formats }}
      graphics: ${{ steps.parse.outputs.graphics }}
      graphics_matrix: ${{ steps.parse.outputs.graphics_matrix }}
      test: ${{ steps.parse.outputs.test }}
      build_all: ${{ steps.parse.outputs.build_all }}
      build_mac: ${{ steps.parse.outputs.build_mac }}
      build_win: ${{ steps.parse.outputs.build_win }}
      build_ios: ${{ steps.parse.outputs.build_ios }}
      build_web: ${{ steps.parse.outputs.build_web }}
      build_skia: ${{ steps.parse.outputs.build_skia }}
      summary: ${{ steps.parse.outputs.summary }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Get PR body for comment trigger
        id: get-pr
        if: github.event_name == 'issue_comment'
        uses: actions/github-script@v7
        with:
          script: |
            const pr = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });
            return pr.data.body || '';
          result-encoding: string

      - name: Parse CI commands
        id: parse
        env:
          EVENT_NAME: ${{ github.event_name }}
          PR_BODY: ${{ github.event.pull_request.body || steps.get-pr.outputs.result || '' }}
          COMMENT_BODY: ${{ github.event.comment.body || '' }}
          INPUT_PROJECTS: ${{ github.event.inputs.projects || '' }}
          INPUT_PLATFORMS: ${{ github.event.inputs.platforms || '' }}
          INPUT_FORMATS: ${{ github.event.inputs.formats || '' }}
          INPUT_GRAPHICS: ${{ github.event.inputs.graphics || '' }}
          INPUT_TEST: ${{ github.event.inputs.test || 'false' }}
        run: |
          # Determine input text and event type based on trigger
          if [ "$EVENT_NAME" = "workflow_dispatch" ]; then
            # Construct /ci-azp command from manual inputs
            INPUT_TEXT="/ci-azp projects=${INPUT_PROJECTS} platforms=${INPUT_PLATFORMS} formats=${INPUT_FORMATS} graphics=${INPUT_GRAPHICS}"
            [ "$INPUT_TEST" = "true" ] && INPUT_TEXT="$INPUT_TEXT test"
            EVENT_TYPE="dispatch"
          elif [ "$EVENT_NAME" = "issue_comment" ]; then
            INPUT_TEXT="$COMMENT_BODY"
            EVENT_TYPE="comment"
          else
            INPUT_TEXT="$PR_BODY"
            EVENT_TYPE="pr"
          fi

          # Call the centralized parser
          echo "$INPUT_TEXT" | python3 Scripts/ci/parse_azp_ci_commands.py --github --event-type "$EVENT_TYPE"

      - name: React to comment
        if: github.event_name == 'issue_comment' && steps.parse.outputs.should_build == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.reactions.createForIssueComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: context.payload.comment.id,
              content: '+1'
            });

      - name: Skip notification
        if: steps.parse.outputs.skip == 'true'
        run: echo "CI build skipped by /ci-azp skip command"

  # macOS build job
  build-mac:
    name: Build macOS
    needs: parse-commands
    if: |
      needs.parse-commands.outputs.should_build == 'true' &&
      needs.parse-commands.outputs.skip != 'true' &&
      needs.parse-commands.outputs.build_mac == 'true'
    runs-on: macos-latest
    strategy:
      fail-fast: false
      matrix:
        graphics: ${{ fromJson(needs.parse-commands.outputs.graphics_matrix) }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Download dependencies
        run: |
          cd Dependencies/IPlug
          ./download-iplug-sdks.sh

      - name: Build projects
        env:
          PROJECTS: ${{ needs.parse-commands.outputs.projects }}
          FORMATS: ${{ needs.parse-commands.outputs.formats }}
          GRAPHICS: ${{ matrix.graphics }}
        run: |
          # Defense-in-depth: validate graphics backend at runtime
          case "$GRAPHICS" in
            nanovg|skia) ;;
            *) echo "Error: Invalid graphics backend: $GRAPHICS"; exit 1 ;;
          esac

          # Convert to uppercase for preprocessor definition
          GRAPHICS_UPPER=$(echo "$GRAPHICS" | tr '[:lower:]' '[:upper:]')

          echo "Building macOS with $GRAPHICS graphics backend"
          echo "Projects: $PROJECTS"
          echo "Formats: $FORMATS"

          IFS=',' read -ra PROJECT_ARRAY <<< "$PROJECTS"
          IFS=',' read -ra FORMAT_ARRAY <<< "$FORMATS"

          # Map format names to Xcode targets
          declare -A FORMAT_TO_TARGET=(
            ["app"]="APP"
            ["vst3"]="VST3"
            ["clap"]="CLAP"
            ["auv2"]="AU"
            ["au"]="AU"
            ["aax"]="AAX"
            ["vst2"]="VST2"
          )

          for project in "${PROJECT_ARRAY[@]}"; do
            # Determine project path
            if [[ "$project" == IGraphics* ]] || [[ "$project" == MetaParamTest ]]; then
              PROJECT_PATH="Tests/$project"
            else
              PROJECT_PATH="Examples/$project"
            fi

            XCODEPROJ="$PROJECT_PATH/projects/${project}-macOS.xcodeproj"
            XCCONFIG="$PROJECT_PATH/config/${project}-mac.xcconfig"

            if [ -d "$XCODEPROJ" ]; then
              echo "Building $project..."

              # Check for xcconfig and prepare args
              XCCONFIG_ARG=""
              if [ -f "$XCCONFIG" ]; then
                XCCONFIG_ARG="-xcconfig $XCCONFIG"
              else
                echo "  Note: xcconfig not found at $XCCONFIG, using default settings"
              fi

              for format in "${FORMAT_ARRAY[@]}"; do
                TARGET="${FORMAT_TO_TARGET[$format]}"
                if [ -n "$TARGET" ]; then
                  echo "  Building $TARGET..."
                  xcodebuild -project "$XCODEPROJ" \
                    -target "$TARGET" \
                    -configuration Release \
                    $XCCONFIG_ARG \
                    GCC_PREPROCESSOR_DEFINITIONS="\$GCC_PREPROCESSOR_DEFINITIONS IGRAPHICS_${GRAPHICS_UPPER}" \
                    2>&1 | tail -100 || echo "  $TARGET build completed with warnings/errors"
                else
                  echo "  Unknown format: $format"
                fi
              done
            else
              echo "Project not found: $XCODEPROJ"
            fi
          done

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: mac-${{ matrix.graphics }}-builds
          path: |
            Examples/*/build/Release/*.app
            Examples/*/build/Release/*.vst3
            Examples/*/build/Release/*.clap
            Examples/*/build/Release/*.component
            Tests/*/build/Release/*.app
          if-no-files-found: ignore

  # Windows build job
  build-win:
    name: Build Windows
    needs: parse-commands
    if: |
      needs.parse-commands.outputs.should_build == 'true' &&
      needs.parse-commands.outputs.skip != 'true' &&
      needs.parse-commands.outputs.build_win == 'true'
    runs-on: windows-2022
    strategy:
      fail-fast: false
      matrix:
        graphics: ${{ fromJson(needs.parse-commands.outputs.graphics_matrix) }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Setup MSBuild
        uses: microsoft/setup-msbuild@v2

      - name: Download dependencies
        shell: bash
        run: |
          cd Dependencies/IPlug
          ./download-iplug-sdks.sh

      - name: Build projects
        shell: pwsh
        env:
          PROJECTS: ${{ needs.parse-commands.outputs.projects }}
          FORMATS: ${{ needs.parse-commands.outputs.formats }}
          GRAPHICS: ${{ matrix.graphics }}
        run: |
          # Defense-in-depth: validate graphics backend at runtime
          if ($env:GRAPHICS -notin @('nanovg', 'skia')) {
            Write-Error "Invalid graphics backend: $env:GRAPHICS"
            exit 1
          }

          Write-Host "Building Windows with $env:GRAPHICS graphics backend"
          Write-Host "Projects: $env:PROJECTS"
          Write-Host "Formats: $env:FORMATS"

          $projects = $env:PROJECTS -split ','
          $formats = $env:FORMATS -split ','

          # Map format names to vcxproj suffixes
          $formatMap = @{
            "app" = "app"
            "vst3" = "vst3"
            "clap" = "clap"
            "auv2" = "auv2"
            "au" = "auv2"
            "aax" = "aax"
            "vst2" = "vst2"
          }

          foreach ($project in $projects) {
            # Determine project path
            if ($project -like "IGraphics*" -or $project -eq "MetaParamTest") {
              $projectPath = "Tests/$project"
            } else {
              $projectPath = "Examples/$project"
            }

            if (Test-Path $projectPath) {
              Write-Host "Building $project..."

              # Switch graphics backend by modifying props file (like Azure Pipelines)
              $propsFile = "$projectPath/config/$project-win.props"
              if ($env:GRAPHICS -eq "skia" -and (Test-Path $propsFile)) {
                Write-Host "  Switching to Skia graphics backend..."
                (Get-Content $propsFile) -replace 'IGRAPHICS_NANOVG;IGRAPHICS_GL2', 'IGRAPHICS_SKIA;IGRAPHICS_GL2' | Set-Content $propsFile
              }

              foreach ($format in $formats) {
                $formatSuffix = $formatMap[$format]
                if (-not $formatSuffix) {
                  Write-Host "  Unknown format: $format"
                  continue
                }

                $vcxproj = "$projectPath/projects/$project-$formatSuffix.vcxproj"
                if (Test-Path $vcxproj) {
                  Write-Host "  Building $($format.ToUpper())..."
                  msbuild $vcxproj `
                    /p:Configuration=Release `
                    /p:Platform=x64 `
                    /m `
                    /verbosity:minimal
                } else {
                  Write-Host "  Project file not found: $vcxproj"
                }
              }
            } else {
              Write-Host "Project path not found: $projectPath"
            }
          }

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: win-${{ matrix.graphics }}-builds
          path: |
            Examples/*/build-win/**/*.exe
            Examples/*/build-win/**/*.vst3
            Examples/*/build-win/**/*.clap
            Tests/*/build-win/**/*.exe
          if-no-files-found: ignore

  # iOS build job
  build-ios:
    name: Build iOS
    needs: parse-commands
    if: |
      needs.parse-commands.outputs.should_build == 'true' &&
      needs.parse-commands.outputs.skip != 'true' &&
      needs.parse-commands.outputs.build_ios == 'true'
    runs-on: macos-latest
    strategy:
      fail-fast: false
      matrix:
        graphics: ${{ fromJson(needs.parse-commands.outputs.graphics_matrix) }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Download dependencies
        run: |
          cd Dependencies/IPlug
          ./download-iplug-sdks.sh

      - name: Build projects
        env:
          PROJECTS: ${{ needs.parse-commands.outputs.projects }}
          GRAPHICS: ${{ matrix.graphics }}
        run: |
          # Defense-in-depth: validate graphics backend at runtime
          case "$GRAPHICS" in
            nanovg|skia) ;;
            *) echo "Error: Invalid graphics backend: $GRAPHICS"; exit 1 ;;
          esac

          # Convert to uppercase for preprocessor definition
          GRAPHICS_UPPER=$(echo "$GRAPHICS" | tr '[:lower:]' '[:upper:]')

          echo "Building iOS with $GRAPHICS graphics backend"
          echo "Projects: $PROJECTS"

          IFS=',' read -ra PROJECT_ARRAY <<< "$PROJECTS"

          for project in "${PROJECT_ARRAY[@]}"; do
            # Determine project path
            if [[ "$project" == IGraphics* ]] || [[ "$project" == MetaParamTest ]]; then
              PROJECT_PATH="Tests/$project"
            else
              PROJECT_PATH="Examples/$project"
            fi

            XCODEPROJ="$PROJECT_PATH/projects/${project}-iOS.xcodeproj"
            XCCONFIG="$PROJECT_PATH/config/${project}-ios.xcconfig"

            if [ -d "$XCODEPROJ" ]; then
              echo "Building $project for iOS..."

              # Check for xcconfig and prepare args
              XCCONFIG_ARG=""
              if [ -f "$XCCONFIG" ]; then
                XCCONFIG_ARG="-xcconfig $XCCONFIG"
              else
                echo "  Note: xcconfig not found at $XCCONFIG, using default settings"
              fi

              xcodebuild -project "$XCODEPROJ" \
                -scheme "iOS-APP with AUv3" \
                -configuration Release \
                -destination 'generic/platform=iOS' \
                $XCCONFIG_ARG \
                CODE_SIGNING_ALLOWED=NO \
                GCC_PREPROCESSOR_DEFINITIONS="\$GCC_PREPROCESSOR_DEFINITIONS IGRAPHICS_${GRAPHICS_UPPER}" \
                2>&1 | tail -100 || echo "  iOS build completed with warnings/errors"
            else
              echo "Project not found: $XCODEPROJ"
            fi
          done

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ios-${{ matrix.graphics }}-builds
          path: |
            Examples/*/build/Release-iphoneos/*.app
            Tests/*/build/Release-iphoneos/*.app
          if-no-files-found: ignore

  # Web build job
  build-web:
    name: Build Web
    needs: parse-commands
    if: |
      needs.parse-commands.outputs.should_build == 'true' &&
      needs.parse-commands.outputs.skip != 'true' &&
      needs.parse-commands.outputs.build_web == 'true'
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Setup Emscripten
        uses: mymindstorm/setup-emsdk@v14
        with:
          version: 'latest'

      - name: Download dependencies
        run: |
          cd Dependencies/IPlug
          ./download-iplug-sdks.sh

      - name: Build projects
        env:
          PROJECTS: ${{ needs.parse-commands.outputs.projects }}
        run: |
          echo "Building Web Audio Modules"
          echo "Projects: $PROJECTS"

          IFS=',' read -ra PROJECT_ARRAY <<< "$PROJECTS"

          for project in "${PROJECT_ARRAY[@]}"; do
            # Determine project path
            if [[ "$project" == IGraphics* ]] || [[ "$project" == MetaParamTest ]]; then
              PROJECT_PATH="Tests/$project"
            else
              PROJECT_PATH="Examples/$project"
            fi

            SCRIPT="$PROJECT_PATH/scripts/makedist-web.sh"
            if [ -f "$SCRIPT" ]; then
              echo "Building WAM for $project..."
              chmod +x "$SCRIPT"
              cd "$PROJECT_PATH/scripts"
              ./makedist-web.sh off 2>&1 | tail -50 || echo "  WAM build completed with warnings/errors"
              cd - > /dev/null
            else
              echo "No web build script for $project (expected: $SCRIPT)"
            fi
          done

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: web-builds
          path: |
            Examples/*/build-web/**/*.wasm
            Examples/*/build-web/**/*.js
            Tests/*/build-web/**/*.wasm
            Tests/*/build-web/**/*.js
          if-no-files-found: ignore

  # macOS test job
  test-mac:
    name: Test macOS
    needs: [parse-commands, build-mac]
    if: |
      needs.parse-commands.outputs.should_build == 'true' &&
      needs.parse-commands.outputs.test == 'true' &&
      needs.parse-commands.outputs.build_mac == 'true' &&
      needs.build-mac.result == 'success'
    runs-on: macos-latest

    steps:
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: mac-*-builds
          merge-multiple: true

      - name: Install pluginval
        run: |
          curl -L "https://github.com/Tracktion/pluginval/releases/download/latest_release/pluginval_macOS.zip" -o pluginval.zip
          unzip pluginval.zip

      - name: Run pluginval on VST3 plugins
        run: |
          for plugin in $(find . -name "*.vst3" -type d); do
            echo "Testing: $plugin"
            ./pluginval.app/Contents/MacOS/pluginval \
              --validate-in-process \
              --skip-gui-tests \
              --timeout-ms 60000 \
              --validate "$plugin" || echo "Warning: $plugin validation had issues"
          done

      - name: Run pluginval on CLAP plugins
        run: |
          for plugin in $(find . -name "*.clap" -type f); do
            echo "Testing: $plugin"
            ./pluginval.app/Contents/MacOS/pluginval \
              --validate-in-process \
              --skip-gui-tests \
              --timeout-ms 60000 \
              --validate "$plugin" || echo "Warning: $plugin validation had issues"
          done

      - name: Run auval on AU plugins
        run: |
          # Install AU plugins to test
          mkdir -p ~/Library/Audio/Plug-Ins/Components/
          for plugin in $(find . -name "*.component" -type d); do
            echo "Installing: $plugin"
            cp -R "$plugin" ~/Library/Audio/Plug-Ins/Components/
          done
          # Kill audio daemon to pick up new plugins
          killall -9 AudioComponentRegistrar 2>/dev/null || true
          sleep 2
          # Run auval on each installed plugin, extracting type/subtype/mfr from Info.plist
          for plugin in ~/Library/Audio/Plug-Ins/Components/*.component; do
            if [ -d "$plugin" ]; then
              PLIST="$plugin/Contents/Info.plist"
              if [ -f "$PLIST" ]; then
                # Extract AU type, subtype, and manufacturer from Info.plist
                TYPE=$(/usr/libexec/PlistBuddy -c "Print :AudioComponents:0:type" "$PLIST" 2>/dev/null || echo "aufx")
                SUBTYPE=$(/usr/libexec/PlistBuddy -c "Print :AudioComponents:0:subtype" "$PLIST" 2>/dev/null || echo "test")
                MFR=$(/usr/libexec/PlistBuddy -c "Print :AudioComponents:0:manufacturer" "$PLIST" 2>/dev/null || echo "Test")
                echo "Testing: $plugin ($TYPE $SUBTYPE $MFR)"
                auval -v "$TYPE" "$SUBTYPE" "$MFR" || echo "Warning: auval had issues with $plugin"
              else
                echo "Warning: No Info.plist found for $plugin"
              fi
            fi
          done

  # Windows test job
  test-win:
    name: Test Windows
    needs: [parse-commands, build-win]
    if: |
      needs.parse-commands.outputs.should_build == 'true' &&
      needs.parse-commands.outputs.test == 'true' &&
      needs.parse-commands.outputs.build_win == 'true' &&
      needs.build-win.result == 'success'
    runs-on: windows-2022

    steps:
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: win-*-builds
          merge-multiple: true

      - name: Install pluginval
        shell: pwsh
        run: |
          Invoke-WebRequest -Uri "https://github.com/Tracktion/pluginval/releases/download/latest_release/pluginval_Windows.zip" -OutFile pluginval.zip
          Expand-Archive pluginval.zip -DestinationPath .

      - name: Run pluginval on VST3 plugins
        shell: pwsh
        run: |
          Get-ChildItem -Recurse -Filter "*.vst3" -Directory | ForEach-Object {
            Write-Host "Testing: $($_.FullName)"
            & .\pluginval.exe --validate-in-process --skip-gui-tests --timeout-ms 60000 --validate $_.FullName
            if ($LASTEXITCODE -ne 0) { Write-Host "Warning: $($_.Name) validation had issues" }
          }

      - name: Run pluginval on CLAP plugins
        shell: pwsh
        run: |
          Get-ChildItem -Recurse -Filter "*.clap" -File | ForEach-Object {
            Write-Host "Testing: $($_.FullName)"
            & .\pluginval.exe --validate-in-process --skip-gui-tests --timeout-ms 60000 --validate $_.FullName
            if ($LASTEXITCODE -ne 0) { Write-Host "Warning: $($_.Name) validation had issues" }
          }

  # Summary job
  summary:
    name: Build Summary
    needs: [parse-commands, build-mac, build-win, build-ios, build-web, test-mac, test-win]
    if: always() && needs.parse-commands.outputs.should_build == 'true'
    runs-on: ubuntu-latest

    steps:
      - name: Post summary comment
        if: github.event_name == 'issue_comment' || github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const buildResults = {
              mac: '${{ needs.build-mac.result }}',
              win: '${{ needs.build-win.result }}',
              ios: '${{ needs.build-ios.result }}',
              web: '${{ needs.build-web.result }}'
            };

            const testResults = {
              'test-mac': '${{ needs.test-mac.result }}',
              'test-win': '${{ needs.test-win.result }}'
            };

            const statusEmoji = {
              'success': '✅',
              'failure': '❌',
              'cancelled': '⚪',
              'skipped': '⏭️'
            };

            let summaryLines = ['## CI Build Results\n'];

            summaryLines.push('### Builds');
            for (const [platform, result] of Object.entries(buildResults)) {
              if (result !== 'skipped') {
                summaryLines.push(`- ${statusEmoji[result] || '❓'} **${platform}**: ${result}`);
              }
            }

            // Only show test section if tests were requested
            const hasTests = Object.values(testResults).some(r => r !== 'skipped');
            if (hasTests) {
              summaryLines.push('\n### Tests');
              for (const [name, result] of Object.entries(testResults)) {
                if (result !== 'skipped') {
                  const displayName = name.replace('test-', '');
                  summaryLines.push(`- ${statusEmoji[result] || '❓'} **${displayName}**: ${result}`);
                }
              }
            }

            summaryLines.push('\n---');
            summaryLines.push(`Configuration: ${{ needs.parse-commands.outputs.summary }}`);

            const issueNumber = context.issue?.number || context.payload.pull_request?.number;
            if (issueNumber) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                body: summaryLines.join('\n')
              });
            }
