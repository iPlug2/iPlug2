name: CI Commands

# This workflow handles /ci commands in PR comments and descriptions
# It parses commands and triggers builds with the specified configuration

on:
  # Trigger on PR comments containing /ci commands
  issue_comment:
    types: [created]

  # Trigger on PR open/edit to parse commands from PR body
  pull_request:
    types: [opened, edited, synchronize]

  # Allow manual triggering with parameters
  workflow_dispatch:
    inputs:
      projects:
        description: 'Projects to build (comma-separated, or "all")'
        required: false
        default: 'IPlugEffect'
        type: string
      platforms:
        description: 'Platforms to build (mac,win,ios,web)'
        required: false
        default: 'mac,win'
        type: string
      formats:
        description: 'Plugin formats (app,vst3,clap,auv2)'
        required: false
        default: 'app,vst3,clap'
        type: string
      graphics:
        description: 'Graphics backends (nanovg,skia,both)'
        required: false
        default: 'nanovg'
        type: string
      test:
        description: 'Run plugin validation tests'
        required: false
        default: false
        type: boolean
      pr_number:
        description: 'PR number (for context)'
        required: false
        type: string

env:
  # Default configuration
  DEFAULT_PROJECTS: 'IPlugEffect'
  DEFAULT_PLATFORMS: 'mac,win'
  DEFAULT_FORMATS: 'app,vst3,clap,auv2'
  DEFAULT_GRAPHICS: 'nanovg'

jobs:
  # Parse CI commands from PR body or comment
  parse-commands:
    name: Parse CI Commands
    runs-on: ubuntu-latest
    # Only run on PR comments that contain /ci, or PR events, or workflow_dispatch
    if: |
      github.event_name == 'workflow_dispatch' ||
      github.event_name == 'pull_request' ||
      (github.event_name == 'issue_comment' &&
       github.event.issue.pull_request &&
       contains(github.event.comment.body, '/ci'))
    outputs:
      should_build: ${{ steps.parse.outputs.should_build }}
      skip: ${{ steps.parse.outputs.skip }}
      projects: ${{ steps.parse.outputs.projects }}
      platforms: ${{ steps.parse.outputs.platforms }}
      formats: ${{ steps.parse.outputs.formats }}
      graphics: ${{ steps.parse.outputs.graphics }}
      test: ${{ steps.parse.outputs.test }}
      build_all: ${{ steps.parse.outputs.build_all }}
      build_mac: ${{ steps.parse.outputs.build_mac }}
      build_win: ${{ steps.parse.outputs.build_win }}
      build_ios: ${{ steps.parse.outputs.build_ios }}
      build_web: ${{ steps.parse.outputs.build_web }}
      build_skia: ${{ steps.parse.outputs.build_skia }}
      summary: ${{ steps.parse.outputs.summary }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Get PR body for comment trigger
        id: get-pr
        if: github.event_name == 'issue_comment'
        uses: actions/github-script@v7
        with:
          script: |
            const pr = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });
            return pr.data.body || '';
          result-encoding: string

      - name: Parse CI commands
        id: parse
        env:
          EVENT_NAME: ${{ github.event_name }}
          PR_BODY: ${{ github.event.pull_request.body || steps.get-pr.outputs.result || '' }}
          COMMENT_BODY: ${{ github.event.comment.body || '' }}
          INPUT_PROJECTS: ${{ github.event.inputs.projects || '' }}
          INPUT_PLATFORMS: ${{ github.event.inputs.platforms || '' }}
          INPUT_FORMATS: ${{ github.event.inputs.formats || '' }}
          INPUT_GRAPHICS: ${{ github.event.inputs.graphics || '' }}
          INPUT_TEST: ${{ github.event.inputs.test || 'false' }}
        run: |
          # Determine input text and event type based on trigger
          if [ "$EVENT_NAME" = "workflow_dispatch" ]; then
            # Construct /ci command from manual inputs
            INPUT_TEXT="/ci projects=${INPUT_PROJECTS} platforms=${INPUT_PLATFORMS} formats=${INPUT_FORMATS} graphics=${INPUT_GRAPHICS}"
            [ "$INPUT_TEST" = "true" ] && INPUT_TEXT="$INPUT_TEXT test"
            EVENT_TYPE="dispatch"
          elif [ "$EVENT_NAME" = "issue_comment" ]; then
            INPUT_TEXT="$COMMENT_BODY"
            EVENT_TYPE="comment"
          else
            INPUT_TEXT="$PR_BODY"
            EVENT_TYPE="pr"
          fi

          # Call the centralized parser
          echo "$INPUT_TEXT" | python3 Scripts/ci/parse_ci_commands.py --github --event-type "$EVENT_TYPE"

      - name: Post acknowledgment comment
        if: github.event_name == 'issue_comment' && steps.parse.outputs.should_build == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const summary = '${{ steps.parse.outputs.summary }}';
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `üî® **CI Build Triggered**\n\n${summary}\n\nBuilds will start shortly...`
            });

      - name: Skip notification
        if: steps.parse.outputs.skip == 'true'
        run: echo "CI build skipped by /ci skip command"

  # macOS build job
  build-mac:
    name: Build macOS
    needs: parse-commands
    if: |
      needs.parse-commands.outputs.should_build == 'true' &&
      needs.parse-commands.outputs.skip != 'true' &&
      needs.parse-commands.outputs.build_mac == 'true'
    runs-on: macos-latest
    strategy:
      fail-fast: false
      matrix:
        graphics: ${{ fromJson(format('["{0}"]', join(fromJson(format('["{0}"]', needs.parse-commands.outputs.graphics)), '","'))) }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Download dependencies
        run: |
          cd Dependencies/IPlug
          ./download-iplug-sdks.sh

      - name: Build projects
        env:
          PROJECTS: ${{ needs.parse-commands.outputs.projects }}
          FORMATS: ${{ needs.parse-commands.outputs.formats }}
          GRAPHICS: ${{ matrix.graphics }}
        run: |
          # Defense-in-depth: validate graphics backend at runtime
          case "$GRAPHICS" in
            nanovg|skia) ;;
            *) echo "Error: Invalid graphics backend: $GRAPHICS"; exit 1 ;;
          esac

          # Convert to uppercase for preprocessor definition
          GRAPHICS_UPPER=$(echo "$GRAPHICS" | tr '[:lower:]' '[:upper:]')

          echo "Building macOS with $GRAPHICS graphics backend"
          echo "Projects: $PROJECTS"
          echo "Formats: $FORMATS"

          IFS=',' read -ra PROJECT_ARRAY <<< "$PROJECTS"
          IFS=',' read -ra FORMAT_ARRAY <<< "$FORMATS"

          for project in "${PROJECT_ARRAY[@]}"; do
            # Determine project path
            if [[ "$project" == IGraphics* ]] || [[ "$project" == MetaParamTest ]]; then
              PROJECT_PATH="Tests/$project"
            else
              PROJECT_PATH="Examples/$project"
            fi

            if [ -d "$PROJECT_PATH" ]; then
              echo "Building $project..."
              cd "$PROJECT_PATH"

              for format in "${FORMAT_ARRAY[@]}"; do
                FORMAT_UPPER=$(echo "$format" | tr '[:lower:]' '[:upper:]')
                SCHEME="${project}-macOS"

                # Check if xcodeproj exists
                if [ -d "${project}.xcodeproj" ]; then
                  echo "  Building $FORMAT_UPPER..."
                  xcodebuild -project "${project}.xcodeproj" \
                    -scheme "$SCHEME" \
                    -configuration Release \
                    -destination 'platform=macOS' \
                    build \
                    GCC_PREPROCESSOR_DEFINITIONS="\$GCC_PREPROCESSOR_DEFINITIONS IGRAPHICS_${GRAPHICS_UPPER}" \
                    2>&1 | tail -50 || echo "Build completed with warnings/errors"
                fi
              done

              cd - > /dev/null
            else
              echo "Project path not found: $PROJECT_PATH"
            fi
          done

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: mac-${{ matrix.graphics }}-builds
          path: |
            Examples/*/build/Release/*.app
            Examples/*/build/Release/*.vst3
            Examples/*/build/Release/*.clap
            Examples/*/build/Release/*.component
            Tests/*/build/Release/*.app
          if-no-files-found: ignore

  # Windows build job
  build-win:
    name: Build Windows
    needs: parse-commands
    if: |
      needs.parse-commands.outputs.should_build == 'true' &&
      needs.parse-commands.outputs.skip != 'true' &&
      needs.parse-commands.outputs.build_win == 'true'
    runs-on: windows-2022
    strategy:
      fail-fast: false
      matrix:
        graphics: ${{ fromJson(format('["{0}"]', join(fromJson(format('["{0}"]', needs.parse-commands.outputs.graphics)), '","'))) }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Setup MSBuild
        uses: microsoft/setup-msbuild@v2

      - name: Download dependencies
        shell: bash
        run: |
          cd Dependencies/IPlug
          ./download-iplug-sdks.sh

      - name: Build projects
        shell: pwsh
        env:
          PROJECTS: ${{ needs.parse-commands.outputs.projects }}
          FORMATS: ${{ needs.parse-commands.outputs.formats }}
          GRAPHICS: ${{ matrix.graphics }}
        run: |
          # Defense-in-depth: validate graphics backend at runtime
          if ($env:GRAPHICS -notin @('nanovg', 'skia')) {
            Write-Error "Invalid graphics backend: $env:GRAPHICS"
            exit 1
          }

          Write-Host "Building Windows with $env:GRAPHICS graphics backend"
          Write-Host "Projects: $env:PROJECTS"
          Write-Host "Formats: $env:FORMATS"

          $projects = $env:PROJECTS -split ','
          $formats = $env:FORMATS -split ','

          foreach ($project in $projects) {
            # Determine project path
            if ($project -like "IGraphics*" -or $project -eq "MetaParamTest") {
              $projectPath = "Tests/$project"
            } else {
              $projectPath = "Examples/$project"
            }

            if (Test-Path $projectPath) {
              Write-Host "Building $project..."
              Push-Location $projectPath

              $slnFile = Get-ChildItem -Filter "*.sln" | Select-Object -First 1
              if ($slnFile) {
                foreach ($format in $formats) {
                  $formatUpper = $format.ToUpper()
                  Write-Host "  Building $formatUpper..."

                  # Set graphics preprocessor
                  $graphicsDefine = "IGRAPHICS_$($env:GRAPHICS.ToUpper())"

                  msbuild $slnFile.Name `
                    /p:Configuration=Release `
                    /p:Platform=x64 `
                    /p:PreprocessorDefinitions="$graphicsDefine" `
                    /m `
                    /verbosity:minimal
                }
              }

              Pop-Location
            } else {
              Write-Host "Project path not found: $projectPath"
            }
          }

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: win-${{ matrix.graphics }}-builds
          path: |
            Examples/*/build-win/**/*.exe
            Examples/*/build-win/**/*.vst3
            Examples/*/build-win/**/*.clap
            Tests/*/build-win/**/*.exe
          if-no-files-found: ignore

  # Web build job
  build-web:
    name: Build Web
    needs: parse-commands
    if: |
      needs.parse-commands.outputs.should_build == 'true' &&
      needs.parse-commands.outputs.skip != 'true' &&
      needs.parse-commands.outputs.build_web == 'true'
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Setup Emscripten
        uses: mymindstorm/setup-emsdk@v14
        with:
          version: 'latest'

      - name: Download dependencies
        run: |
          cd Dependencies/IPlug
          ./download-iplug-sdks.sh

      - name: Build projects
        env:
          PROJECTS: ${{ needs.parse-commands.outputs.projects }}
        run: |
          echo "Building Web Audio Modules"
          echo "Projects: $PROJECTS"

          IFS=',' read -ra PROJECT_ARRAY <<< "$PROJECTS"

          for project in "${PROJECT_ARRAY[@]}"; do
            # Determine project path
            if [[ "$project" == IGraphics* ]] || [[ "$project" == MetaParamTest ]]; then
              PROJECT_PATH="Tests/$project"
            else
              PROJECT_PATH="Examples/$project"
            fi

            if [ -d "$PROJECT_PATH" ]; then
              MAKEFILE="$PROJECT_PATH/Makefile"
              if [ -f "$MAKEFILE" ]; then
                echo "Building WAM for $project..."
                cd "$PROJECT_PATH"
                emmake make WAM || echo "WAM build completed"
                cd - > /dev/null
              fi
            fi
          done

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: web-builds
          path: |
            Examples/*/build-web/**/*.wasm
            Examples/*/build-web/**/*.js
            Tests/*/build-web/**/*.wasm
            Tests/*/build-web/**/*.js
          if-no-files-found: ignore

  # Summary job
  summary:
    name: Build Summary
    needs: [parse-commands, build-mac, build-win, build-web]
    if: always() && needs.parse-commands.outputs.should_build == 'true'
    runs-on: ubuntu-latest

    steps:
      - name: Post summary comment
        if: github.event_name == 'issue_comment' || github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const results = {
              mac: '${{ needs.build-mac.result }}',
              win: '${{ needs.build-win.result }}',
              web: '${{ needs.build-web.result }}'
            };

            const statusEmoji = {
              'success': '‚úÖ',
              'failure': '‚ùå',
              'cancelled': '‚ö™',
              'skipped': '‚è≠Ô∏è'
            };

            let summaryLines = ['## CI Build Results\n'];

            for (const [platform, result] of Object.entries(results)) {
              if (result !== 'skipped') {
                summaryLines.push(`- ${statusEmoji[result] || '‚ùì'} **${platform}**: ${result}`);
              }
            }

            summaryLines.push('\n---');
            summaryLines.push(`Configuration: ${{ needs.parse-commands.outputs.summary }}`);

            const issueNumber = context.issue?.number || context.payload.pull_request?.number;
            if (issueNumber) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                body: summaryLines.join('\n')
              });
            }
