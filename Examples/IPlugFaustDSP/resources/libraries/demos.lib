//#################################### demos.lib ##########################################
// This library contains a set of demo functions based on examples located in the
// `/examples` folder. Its official prefix is `dm`.
//
// #### References
// * <https://github.com/grame-cncm/faustlibraries/blob/master/demos.lib>
//########################################################################################

/************************************************************************
************************************************************************
FAUST library file, GRAME section

Except where noted otherwise, Copyright (C) 2003-2017 by GRAME,
Centre National de Creation Musicale.
----------------------------------------------------------------------
GRAME LICENSE

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as
published by the Free Software Foundation; either version 2.1 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with the GNU C Library; if not, write to the Free
Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
02111-1307 USA.

EXCEPTION TO THE LGPL LICENSE : As a special exception, you may create a
larger FAUST program which directly or indirectly imports this library
file and still distribute the compiled code generated by the FAUST
compiler, or a modified version of this compiled code, under your own
copyright and license. This EXCEPTION TO THE LGPL LICENSE explicitly
grants you the right to freely choose the license for the resulting
compiled code. In particular the resulting compiled code has no obligation
to be LGPL or GPL. For example you are free to choose a commercial or
closed source license or any other license if you decide so.
************************************************************************
************************************************************************/

ma = library("maths.lib");
ba = library("basics.lib");
de = library("delays.lib");
si = library("signals.lib");
an = library("analyzers.lib");
fi = library("filters.lib");
os = library("oscillators.lib");
no = library("noises.lib");
ef = library("misceffects.lib");
co = library("compressors.lib");
ve = library("vaeffects.lib");
pf = library("phaflangers.lib");
re = library("reverbs.lib");
en = library("envelopes.lib");
it = library("interpolators.lib");
aa = library("aanl.lib");
sp = library("spats.lib");

declare name "Faust Demos Library";
declare version "1.2.0";

//########################################################################################
/************************************************************************
FAUST library file, jos section

Except where noted otherwise, The Faust functions below in this
section are Copyright (C) 2003-2019 by Julius O. Smith III <jos@ccrma.stanford.edu>
([jos](http://ccrma.stanford.edu/~jos/)), and released under the
(MIT-style) [STK-4.3](#stk-4.3-license) license.

MarkDown comments in this section are Copyright 2016-2019 by Romain
Michon and Julius O. Smith III, and are released under the
[CCA4I](https://creativecommons.org/licenses/by/4.0/) license (TODO: if/when Romain agrees!)

************************************************************************/

//====================================Analyzers===========================================
//========================================================================================

//----------------------`(dm.)mth_octave_spectral_level_demo`----------------------
// Demonstrate mth_octave_spectral_level in a standalone GUI.
//
// #### Usage
// ```
// _ : mth_octave_spectral_level_demo(BandsPerOctave) : _
// _ : spectral_level_demo : _ // 2/3 octave
// ```
//------------------------------------------------------------
declare mth_octave_spectral_level_demo author "Julius O. Smith III and Yann Orlarey";
declare mth_octave_spectral_level_demo licence "MIT";

mth_octave_spectral_level_demo(BPO) =  an.mth_octave_spectral_level_default(M,ftop,N,tau,dB_offset)
with{
    M = BPO;
    ftop = 16000;
    Noct = 10; // number of octaves down from ftop
    // Lowest band-edge is at ftop*2^(-Noct+2) = 62.5 Hz when ftop=16 kHz:
    N = int(Noct*M); // without 'int()', segmentation fault observed for M=1.67
    ctl_group(x)  = hgroup("[1] SPECTRUM ANALYZER CONTROLS", x);
    tau = ctl_group(hslider("[0] Level Averaging Time [unit:ms] [scale:log]
        [tooltip: band-level averaging time in milliseconds]",
    100,1,10000,1)) * 0.001;
    dB_offset = ctl_group(hslider("[1] Level dB Offset [unit:dB]
    [tooltip: Level offset in decibels]",
    50,-50,100,1));
};

spectral_level_demo = mth_octave_spectral_level_demo(1.5); // 2/3 octave


//======================================Filters===========================================
//========================================================================================

//--------------------------`(dm.)parametric_eq_demo`------------------------------
// A parametric equalizer application.
//
// #### Usage:
//
// ```
// _ : parametric_eq_demo : _
// ```
//------------------------------------------------------------
declare parametric_eq_demo author "Julius O. Smith III";
declare parametric_eq_demo licence "MIT";

parametric_eq_demo = fi.low_shelf(LL,FL) : fi.peak_eq(LP,FP,BP) : fi.high_shelf(LH,FH)
with{
    eq_group(x) = hgroup("[0] PARAMETRIC EQ SECTIONS [tooltip: See Faust's filters.lib
        for info and pointers]",x);
    ls_group(x) = eq_group(vgroup("[1] Low Shelf",x));

    LL = ls_group(hslider("[0] Low Boost|Cut [unit:dB] [style:knob]
        [tooltip: Amount of low-frequency boost or cut in decibels]",0,-40,40,0.1));
    FL = ls_group(hslider("[1] Transition Frequency [unit:Hz] [style:knob] [scale:log]
        [tooltip: Transition-frequency from boost (cut) to unity gain]",200,1,5000,1));

    pq_group(x) = eq_group(vgroup("[2] Peaking Equalizer[tooltip: Parametric Equalizer
        sections from filters.lib]",x));
    LP = pq_group(hslider("[0] Peak Boost|Cut [unit:dB] [style:knob][tooltip: Amount of
        local boost or cut in decibels]",0,-40,40,0.1));
    FP = pq_group(hslider("[1] Peak Frequency [unit:PK] [style:knob] [tooltip: Peak
        Frequency in Piano Key (PK) units (A440 = 49PK)]",49,1,100,1)) : si.smooth(0.999)
        : ba.pianokey2hz;
    Q = pq_group(hslider("[2] Peak Q [style:knob] [scale:log] [tooltip: Quality factor
        (Q) of the peak = center-frequency/bandwidth]",40,1,1000,0.1));

    BP = FP/Q;

    hs_group(x) = eq_group(vgroup("[3] High Shelf [tooltip: A high shelf provides a boost
        or cut above some frequency]",x));
    LH = hs_group(hslider("[0] High Boost|Cut [unit:dB] [style:knob] [tooltip: Amount of
        high-frequency boost or cut in decibels]",0,-40,40,.1));
    FH = hs_group(hslider("[1] Transition Frequency [unit:Hz] [style:knob] [scale:log]
    [tooltip: Transition-frequency from boost (cut) to unity gain]",8000,20,10000,1));
};


//-------------------`(dm.)spectral_tilt_demo`-----------------------
// A spectral tilt application.
//
// #### Usage
//
// ```
// _ : spectral_tilt_demo(N) : _ 
// ```
//
// Where:
//
// * `N`: filter order (integer)
//
// All other parameters interactive
//------------------------------------------------------------
declare spectral_tilt_demo author "Julius O. Smith III";
declare spectral_tilt_demo licence "MIT";

spectral_tilt_demo(N) = fi.spectral_tilt(O,f0,bw,alpha)
with{
    O = N;
    alpha = hslider("[1] Slope of Spectral Tilt across Band",-1/2,-1,1,0.001);
    f0 = hslider("[2] Band Start Frequency [unit:Hz]",100,20,10000,1);
    bw = hslider("[3] Band Width [unit:Hz]",5000,100,10000,1);
};


//---------`(dm.)mth_octave_filterbank_demo` and `(dm.)filterbank_demo`-------------
// Graphic Equalizer: each filter-bank output signal routes through a fader.
//
// #### Usage
//
// ```
// _ : mth_octave_filterbank_demo(M) : _
// _ : filterbank_demo : _
// ```
//
// Where:
//
// * `M`: number of bands per octave
//--------------------------------------------------------------
declare mth_octave_filterbank_demo author "Julius O. Smith III";
declare mth_octave_filterbank_demo licence "MIT";

mth_octave_filterbank_demo(O) = bp1(bp,mthoctavefilterbankdemo)
with{
    M = O;
    bp1 = ba.bypass1;
    mofb_group(x) = vgroup("CONSTANT-Q FILTER BANK (Butterworth dyadic tree)
        [tooltip: See Faust's filters.lib for documentation and references]", x);
    bypass_group(x) = mofb_group(hgroup("[0]", x));
    slider_group(x) = mofb_group(hgroup("[1]", x));

    N = 10*M; // total number of bands (highpass band, octave-bands, dc band)
    ftop = 10000;
    mthoctavefilterbankdemo = chan;
    chan = fi.mth_octave_filterbank_default(M,ftop,N) : sum(i,N,(*(ba.db2linear(fader(N-i)))));
    fader(i) = slider_group(vslider("Band%2i [unit:dB] [tooltip: Bandpass filter
        gain in dB]", -10, -70, 10, 0.1)) : si.smoo;
    bp = bypass_group(checkbox("[0] Bypass
        [tooltip: When this is checked, the filter-bank has no effect]"));
};

filterbank_demo = mth_octave_filterbank_demo(1); // octave-bands = default


//======================================Effects===========================================
//========================================================================================

//---------------------------`(dm.)cubicnl_demo`--------------------------
// Distortion demo application.
//
// #### Usage:
//
// ```
// _ : cubicnl_demo : _
// ```
//------------------------------------------------------------
declare cubicnl_demo author "Julius O. Smith III";
declare cubicnl_demo licence "MIT";

cubicnl_demo = ba.bypass1(bp, ef.cubicnl_nodc(drive:si.smoo,offset:si.smoo))
with{
    cnl_group(x)  = vgroup("CUBIC NONLINEARITY cubicnl [tooltip: Reference:
        https://ccrma.stanford.edu/~jos/pasp/Cubic_Soft_Clipper.html]", x);
    bp = cnl_group(checkbox("[0] Bypass [tooltip: When this is checked, the
        nonlinearity has no effect]"));
    drive = cnl_group(hslider("[1] Drive [tooltip: Amount of distortion]",
        0, 0, 1, 0.01));
    offset = cnl_group(hslider("[2] Offset [tooltip: Brings in even harmonics]",
        0, 0, 1, 0.01));
};


//----------------------------`(dm.)gate_demo`-------------------------
// Gate demo application.
//
// #### Usage
//
// ```
// _,_ : gate_demo : _,_
// ```
//------------------------------------------------------------
declare gate_demo author "Julius O. Smith III";
declare gate_demo licence "MIT";

gate_demo = ba.bypass2(gbp,gate_stereo_demo)
with{
    gate_group(x) = vgroup("GATE  [tooltip: Reference:
        http://en.wikipedia.org/wiki/Noise_gate]", x);
    meter_group(x) = gate_group(hgroup("[0]", x));
    knob_group(x) = gate_group(hgroup("[1]", x));

    gbp = meter_group(checkbox("[0] Bypass    [tooltip: When this is checked,
        the gate has no effect]"));

    gateview = ef.gate_gain_mono(gatethr,gateatt,gatehold,gaterel) : ba.linear2db :
    meter_group(hbargraph("[1] Gate Gain [unit:dB] [tooltip: Current gain of the
    gate in dB]", -50,+10)); // [style:led]

    gate_stereo_demo(x,y) = attach(x,gateview(abs(x)+abs(y))),y :
    ef.gate_stereo(gatethr,gateatt,gatehold,gaterel);

    gatethr = knob_group(hslider("[1] Threshold [unit:dB] [style:knob] [tooltip: When
        the signal level falls below the Threshold (expressed in dB), the signal is
        muted]", -30, -120, 0, 0.1));

    gateatt = knob_group(hslider("[2] Attack [unit:us] [style:knob] [scale:log]
    [tooltip: Time constant in MICROseconds (1/e smoothing time) for the gate
    gain to go (exponentially) from 0 (muted) to 1 (unmuted)]",
    10, 10, 10000, 1)) : *(0.000001) : max(1.0/float(ma.SR));

    gatehold = knob_group(hslider("[3] Hold [unit:ms] [style:knob] [scale:log]
    [tooltip: Time in ms to keep the gate open (no muting) after the signal
    level falls below the Threshold]", 200, 1, 1000, 1)) : *(0.001) :
    max(1.0/float(ma.SR));

    gaterel = knob_group(hslider("[4] Release [unit:ms] [style:knob] [scale:log]
    [tooltip: Time constant in ms (1/e smoothing time) for the gain to go
    (exponentially) from 1 (unmuted) to 0 (muted)]",
    100, 1, 1000, 1)) : *(0.001) : max(1.0/float(ma.SR));
};


//----------------------------`(dm.)compressor_demo`-------------------------
// Compressor demo application.
//
// #### Usage
//
// ```
// _,_ : compressor_demo : _,_
// ```
//------------------------------------------------------------
declare compressor_demo author "Julius O. Smith III";
declare compressor_demo licence "MIT";

compressor_demo = ba.bypass2(cbp,compressor_stereo_demo)
with{
    comp_group(x) = vgroup("COMPRESSOR [tooltip: Reference:
        http://en.wikipedia.org/wiki/Dynamic_range_compression]", x);

    meter_group(x) = comp_group(hgroup("[0]", x));
    knob_group(x) = comp_group(hgroup("[1]", x));

    cbp = meter_group(checkbox("[0] Bypass    [tooltip: When this is checked, the compressor
        has no effect]"));
    gainview = co.compression_gain_mono(ratio,threshold,attack,release) : ba.linear2db :
    meter_group(hbargraph("[1] Compressor Gain Before Makeup [unit:dB] [tooltip: Current gain of
    the compressor in dB]",-50,+10));

    displaygain = _,_ <: _,_,(abs,abs:+) : _,_,gainview : _,attach;

    compressor_stereo_demo =
    displaygain(co.compressor_stereo(ratio,threshold,attack,release)) :
    *(makeupgain), *(makeupgain);

    ctl_group(x) = knob_group(hgroup("[3] Compression Control", x));

    ratio = ctl_group(hslider("[0] Ratio [style:knob]
    [tooltip: A compression Ratio of N means that for each N dB increase in input
    signal level above Threshold, the output level goes up 1 dB]",
    5, 1, 20, 0.1));

    threshold = ctl_group(hslider("[1] Threshold [unit:dB] [style:knob]
    [tooltip: When the signal level exceeds the Threshold (in dB), its level
    is compressed according to the Ratio]",
    -30, -100, 10, 0.1));

    env_group(x) = knob_group(hgroup("[4] Compression Response", x));

    attack = env_group(hslider("[1] Attack [unit:ms] [style:knob] [scale:log]
    [tooltip: Time constant in ms (1/e smoothing time) for the compression gain
    to approach (exponentially) a new lower target level (the compression
    `kicking in')]", 50, 1, 1000, 0.1)) : *(0.001) : max(1/ma.SR);

    release = env_group(hslider("[2] Release [unit:ms] [style: knob] [scale:log]
    [tooltip: Time constant in ms (1/e smoothing time) for the compression gain
    to approach (exponentially) a new higher target level (the compression
    'releasing')]", 500, 1, 1000, 0.1)) : *(0.001) : max(1/ma.SR);

    makeupgain = comp_group(hslider("[5] Makeup Gain [unit:dB]
    [tooltip: The compressed-signal output level is increased by this amount
    (in dB) to make up for the level lost due to compression]",
    40, -96, 96, 0.1)) : ba.db2linear;
};


//-------------------------`(dm.)moog_vcf_demo`---------------------------
// Illustrate and compare all three Moog VCF implementations above.
//
// #### Usage
//
// ```
// _ : moog_vcf_demo : _
// ```
//------------------------------------------------------------
declare moog_vcf_demo author "Julius O. Smith III";
declare moog_vcf_demo licence "MIT";

moog_vcf_demo = ba.bypass1(bp,vcf)
with{
    mvcf_group(x) = hgroup("MOOG VCF (Voltage Controlled Filter) [tooltip: See Faust's
        vaeffects.lib for info and references]",x);
    cb_group(x) = mvcf_group(hgroup("[0]",x));

    bp = cb_group(checkbox("[0] Bypass  [tooltip: When this is checked, the Moog VCF
        has no effect]"));
    archsw = cb_group(checkbox("[1] Use Biquads [tooltip: Select moog_vcf_2b (two-biquad)
        implementation, instead of the default moog_vcf (analog style) implementation]"));
    bqsw = cb_group(checkbox("[2] Normalized Ladders [tooltip: If using biquads, make
        them normalized ladders (moog_vcf_2bn)]"));

    freq = mvcf_group(hslider("[1] Corner Frequency [unit:PK] [tooltip: The VCF resonates
        at the corner frequency (specified in PianoKey (PK) units, with A440 = 49 PK).
        The VCF response is flat below the corner frequency, and rolls off -24 dB per
        octave above.]",
        25, 1, 88, 0.01) : ba.pianokey2hz) : si.smoo;

    res = mvcf_group(hslider("[2] Corner Resonance [style:knob] [tooltip: Amount of
        resonance near VCF corner frequency (specified between 0 and 1)]", 0.9, 0, 1, 0.01));

    outgain = mvcf_group(hslider("[3] VCF Output Level [unit:dB] [style:knob] [tooltip:
        output level in decibels]", 5, -60, 20, 0.1)) : ba.db2linear : si.smoo;

    vcfbq = _ <: select2(bqsw, ve.moog_vcf_2b(res,freq), ve.moog_vcf_2bn(res,freq));
    vcfarch = _ <: select2(archsw, ve.moog_vcf(res^4,freq), vcfbq);
    vcf = vcfarch : *(outgain);
};


//-------------------------`(dm.)wah4_demo`---------------------------
// Wah pedal application.
//
// #### Usage
//
// ```
// _ : wah4_demo : _
// ```
//------------------------------------------------------------
declare wah4_demo author "Julius O. Smith III";
declare wah4_demo licence "MIT";

wah4_demo = ba.bypass1(bp, ve.wah4(fr))
with{
    wah4_group(x) = hgroup("WAH4 [tooltip: Fourth-order wah effect made using moog_vcf]", x);
    bp = wah4_group(checkbox("[0] Bypass [tooltip: When this is checked, the wah pedal has
        no effect]"));
    fr = wah4_group(hslider("[1] Resonance Frequency [scale:log] [tooltip: wah resonance
        frequency in Hz]", 200,100,2000,1));
    // Avoid dc with the moog_vcf (amplitude too high when freq comes up from dc)
    // Also, avoid very high resonance frequencies (e.g., 5kHz or above).
};

//-------------------------`(dm.)crybaby_demo`---------------------------
// Crybaby effect application.
//
// #### Usage
//
// ```
// _ : crybaby_demo : _
// ```
//------------------------------------------------------------
declare crybaby_demo author "Julius O. Smith III";
declare crybaby_demo licence "MIT";

crybaby_demo = ba.bypass1(bp, ve.crybaby(wah))
with{
    crybaby_group(x) = hgroup("CRYBABY [tooltip: Reference:
        https://ccrma.stanford.edu/~jos/pasp/vegf.html]", x);
    bp = crybaby_group(checkbox("[0] Bypass [tooltip: When this is checked, the wah
        pedal has no effect]"));
    wah = crybaby_group(hslider("[1] Wah parameter [tooltip: wah pedal angle between
        0 (rocked back) and 1 (rocked forward)]",0.8,0,1,0.01));
};

//-------------------------`(dm.)flanger_demo`---------------------------
// Flanger effect application.
//
// #### Usage
//
// ```
// _,_ : flanger_demo : _,_
// ```
//------------------------------------------------------------
declare flanger_demo author "Julius O. Smith III";
declare flanger_demo licence "MIT";

flanger_demo = ba.bypass2(fbp,flanger_stereo_demo)
with{
    flanger_group(x) = vgroup("FLANGER
        [tooltip: Reference: https://ccrma.stanford.edu/~jos/pasp/Flanging.html]", x);
    meter_group(x) = flanger_group(hgroup("[0]", x));
    ctl_group(x) = flanger_group(hgroup("[1]", x));
    del_group(x) = flanger_group(hgroup("[2] Delay Controls", x));
    lvl_group(x) = flanger_group(hgroup("[3]", x));

    fbp = meter_group(checkbox("[0] Bypass    [tooltip: When this is checked, the flanger
        has no effect]"));
    invert = meter_group(checkbox("[1] Invert Flange Sum"));

    // FIXME: This should be an amplitude-response display:
    flangeview = lfor(freq) + lfol(freq) : meter_group(hbargraph("[2] Flange LFO
        [style: led] [tooltip: Display sum of flange delays]", -1.5,+1.5));

    flanger_stereo_demo(x,y) = attach(x,flangeview),y :
        *(level),*(level) : pf.flanger_stereo(dmax,curdel1,curdel2,depth,fb,invert);

    lfol = os.oscrs;
    lfor = os.oscrc;

    dmax = 2048;
    dflange = 0.001 * ma.SR *
        del_group(hslider("[1] Flange Delay [unit:ms] [style:knob]", 10, 0, 20, 0.001));
    odflange = 0.001 * ma.SR *
    del_group(hslider("[2] Delay Offset [unit:ms] [style:knob]", 1, 0, 20, 0.001));
    freq   = ctl_group(hslider("[1] Speed [unit:Hz] [style:knob]", 0.5, 0, 10, 0.01));
    depth  = ctl_group(hslider("[2] Depth [style:knob]", 1, 0, 1, 0.001));
    fb     = ctl_group(hslider("[3] Feedback [style:knob]", 0, -0.999, 0.999, 0.001));
    level  = lvl_group(hslider("Flanger Output Level [unit:dB]", 0, -60, 10, 0.1)) :
        ba.db2linear;
    curdel1 = odflange+dflange*(1 + lfol(freq))/2;
    curdel2 = odflange+dflange*(1 + lfor(freq))/2;
};


//-------------------------`(dm.)phaser2_demo`---------------------------
// Phaser effect demo application.
//
// #### Usage
//
// ```
// _,_ : phaser2_demo : _,_
// ```
//------------------------------------------------------------
declare phaser2_demo author "Julius O. Smith III";
declare phaser2_demo licence "MIT";

phaser2_demo = ba.bypass2(pbp,phaser2_stereo_demo)
with{
    phaser2_group(x) = vgroup("PHASER2 [tooltip: Reference:
        https://ccrma.stanford.edu/~jos/pasp/Flanging.html]", x);
    meter_group(x) = phaser2_group(hgroup("[0]", x));
    ctl_group(x) = phaser2_group(hgroup("[1]", x));
    nch_group(x) = phaser2_group(hgroup("[2]", x));
    lvl_group(x) = phaser2_group(hgroup("[3]", x));

    pbp = meter_group(checkbox("[0] Bypass    [tooltip: When this is checked, the phaser
        has no effect]"));
    invert = meter_group(checkbox("[1] Invert Internal Phaser Sum"));
    vibr = meter_group(checkbox("[2] Vibrato Mode")); // In this mode you can hear any "Doppler"

    // FIXME: This should be an amplitude-response display:
    // flangeview = phaser2_amp_resp : meter_group(hspectrumview("[2] Phaser Amplitude Response", 0,1));
    // phaser2_stereo_demo(x,y) = attach(x,flangeview),y : ...

    phaser2_stereo_demo = *(level),*(level) :
        pf.phaser2_stereo(Notches,width,frqmin,fratio,frqmax,speed,mdepth,fb,invert);

    Notches = 4; // Compile-time parameter: 2 is typical for analog phaser stomp-boxes

    // FIXME: Add tooltips
    speed  = ctl_group(hslider("[1] Speed [unit:Hz] [style:knob]", 0.5, 0, 10, 0.001));
    depth = ctl_group(hslider("[2] Notch Depth (Intensity) [style:knob]", 1, 0, 1, 0.001));
    fb  = ctl_group(hslider("[3] Feedback Gain [style:knob]", 0, -0.999, 0.999, 0.001));

    width  = nch_group(hslider("[1] Notch width [unit:Hz] [style:knob] [scale:log]",
        1000, 10, 5000, 1));
    frqmin = nch_group(hslider("[2] Min Notch1 Freq [unit:Hz] [style:knob] [scale:log]",
        100, 20, 5000, 1));
    frqmax = nch_group(hslider("[3] Max Notch1 Freq [unit:Hz] [style:knob] [scale:log]",
        800, 20, 10000, 1)) : max(frqmin);
    fratio = nch_group(hslider("[4] Notch Freq Ratio: NotchFreq(n+1)/NotchFreq(n) [style:knob]",
        1.5, 1.1, 4, 0.001));

    level  = lvl_group(hslider("Phaser Output Level [unit:dB]", 0, -60, 10, 0.1)) :
        ba.db2linear;

    mdepth = select2(vibr,depth,2); // Improve "ease of use"
};

//-------------------------`(dm.)tapeStop_demo`---------------------------
// Stereo tape-stop effect.
//
// #### Usage
//
// ```
// _,_ : tapeStop_demo : _,_
// ```
//------------------------------------------------------------
declare tapeStop_demo author "David Braun";
declare tapeStop_demo copyright "Copyright (C) 2024 by David Braun <braun@ccrma.stanford.edu>";
declare tapeStop_demo license "MIT-style STK-4.3 license";

tapeStop_demo = hgroup("Tape Stop", ef.tapeStop(2, LAGRANGE_ORDER, MAX_TIME_SAMP, crossfade, gainAlpha, stopAlpha, stopTime, stop))
with {
    LAGRANGE_ORDER = 3;
    MAX_TIME_SEC = 4;
    MIN_TIME_SEC = 0.01;
    MIN_ALPHA = .01;
    MAX_ALPHA = 2;

    MAX_TIME_SAMP = MAX_TIME_SEC : ba.sec2samp;
    msec2samp = _/1000 : ba.sec2samp;

    stop = checkbox("[0] Stop");
    stopTime = hslider("[1] Stop Time [style:knob][unit:ms]", 100, MIN_TIME_SEC*1000, MAX_TIME_SEC*1000, 1) : msec2samp;
    stopAlpha = hslider("[2] Stop Alpha [style:knob][tooltip:Alpha==1 represents a linear deceleration (constant force). Alpha<1 represents an initially weaker, then stronger force. Alpha>1 represents an initially stronger, then weaker force.]", 1, MIN_ALPHA, MAX_ALPHA, .01);
    gainAlpha = hslider("[3] Gain Alpha [style:knob][tooltip:During the tape-stop, lower alpha stays louder longer]", 1, MIN_ALPHA, MAX_ALPHA, .01);
    crossfade = hslider("[4] Crossfade [style:knob][unit:ms][tooltip:Crossfade to apply when resuming normal playback.]", 3, 0, 125, 1) : msec2samp;
};

//======================================Reverbs===========================================
//========================================================================================

//----------------------------`(dm.)freeverb_demo`-------------------------
// Freeverb demo application.
//
// #### Usage
//
// ```
// _,_ : freeverb_demo : _,_
// ```
//------------------------------------------------------------
declare freeverb_demo author " Romain Michon";
declare freeverb_demo licence "LGPL";

freeverb_demo = _,_ <: (*(g)*fixedgain,*(g)*fixedgain :
    re.stereo_freeverb(combfeed, allpassfeed, damping, spatSpread)),
    *(1-g), *(1-g) :> _,_
with{
    scaleroom   = 0.28;
    offsetroom  = 0.7;
    allpassfeed = 0.5;
    scaledamp   = 0.4;
    fixedgain   = 0.1;
    origSR = 44100;

    parameters(x) = hgroup("Freeverb",x);
    knobGroup(x) = parameters(vgroup("[0]",x));
    damping = knobGroup(vslider("[0] Damp [style: knob] [tooltip: Somehow control the
        density of the reverb.]",0.5, 0, 1, 0.025)*scaledamp*origSR/ma.SR);
    combfeed = knobGroup(vslider("[1] RoomSize [style: knob] [tooltip: The room size
        between 0 and 1 with 1 for the largest room.]", 0.5, 0, 1, 0.025)*scaleroom*
        origSR/ma.SR + offsetroom);
    spatSpread = knobGroup(vslider("[2] Stereo Spread [style: knob] [tooltip: Spatial
        spread between 0 and 1 with 1 for maximum spread.]",0.5,0,1,0.01)*46*ma.SR/origSR
        : int);
    g = parameters(vslider("[1] Wet [tooltip: The amount of reverb applied to the signal
        between 0 and 1 with 1 for the maximum amount of reverb.]", 0.3333, 0, 1, 0.025));
};

//---------------------`(dm.)stereo_reverb_tester`--------------------
// Handy test inputs for reverberator demos below.
//
// #### Usage
//
// ```
// _,_ : stereo_reverb_tester(gui_group) : _,_
// ```
// For suppressing the `gui_group` input, pass it as `!`.
// (See `(dm.)fdnrev0_demo` for an example of its use).
//------------------------------------------------------------
declare stereo_reverb_tester author "Julius O. Smith III";
declare stereo_reverb_tester licence "MIT";

stereo_reverb_tester(revin_group,x,y) = reverb_tester(_,x,y)
with {
    reverb_tester(revin_group,x,y) = inx,iny with {
        ck_group(x) = revin_group(vgroup("[1] Input Config",x));
        mutegain = 1 - ck_group(checkbox("[1] Mute Ext Inputs
        [tooltip: When this is checked, the stereo external audio inputs are
        disabled (good for hearing the impulse response or pink-noise response alone)]"));
        pinkin = ck_group(checkbox("[2] Pink Noise
        [tooltip: Pink Noise (or 1/f noise) is Constant-Q Noise (useful for adjusting
        the EQ sections)]"));

        imp_group(x) = revin_group(hgroup("[2] Impulse Selection",x));
        pulseL = imp_group(button("[1] Left
        [tooltip: Send impulse into LEFT channel]")) : ba.impulsify;
        pulseC = imp_group(button("[2] Center
        [tooltip: Send impulse into LEFT and RIGHT channels]")) : ba.impulsify;
        pulseR = imp_group(button("[3] Right
        [tooltip: Send impulse into RIGHT channel]")) : ba.impulsify;

        inx = x*mutegain + (pulseL+pulseC) + pn;
        iny = y*mutegain + (pulseR+pulseC) + pn;
        pn = 0.1*pinkin*no.pink_noise;
    };
};


//-------------------------`(dm.)fdnrev0_demo`---------------------------
// A reverb application using `fdnrev0`.
//
// #### Usage
//
// ```
// _,_,_,_ : fdnrev0_demo(N,NB,BBSO) : _,_
// ```
//
// Where:
//
// * `N`: feedback Delay Network (FDN) order / number of delay lines used =
//    order of feedback matrix / 2, 4, 8, or 16 [extend primes array below for
//    32, 64, ...]
// * `NB`: number of frequency bands / Number of (nearly) independent T60 controls
//    / Integer 3 or greater
// * `BBSO` : butterworth band-split order / order of lowpass/highpass bandsplit
//    used at each crossover freq / odd positive integer
//------------------------------------------------------------
declare fdnrev0_demo author "Julius O. Smith III";
declare fdnrev0_demo licence "MIT";

fdnrev0_demo(N,NB,BBSO) = stereo_reverb_tester(revin_group)
      <: re.fdnrev0(MAXDELAY,delays,BBSO,freqs,durs,loopgainmax,nonl)
      :> *(gain),*(gain)
with{
    MAXDELAY = 8192; // sync w delays and prime_power_delays above
    defdurs = (8.4,6.5,5.0,3.8,2.7); // NB default durations (sec)
    deffreqs = (500,1000,2000,4000); // NB-1 default crossover frequencies (Hz)
    deflens = (56.3,63.0); // 2 default min and max path lengths

    fdn_group(x) = vgroup("FEEDBACK DELAY NETWORK (FDN) REVERBERATOR, ORDER 16
    [tooltip: See Faust's reverbs.lib for documentation and references]", x);

    freq_group(x) = fdn_group(vgroup("[1] Band Crossover Frequencies", x));
    t60_group(x) = fdn_group(hgroup("[2] Band Decay Times (T60)", x));
    path_group(x) = fdn_group(vgroup("[3] Room Dimensions", x));
    revin_group(x) = fdn_group(hgroup("[4] Input Controls", x));
    nonl_group(x) = revin_group(vgroup("[4] Nonlinearity",x));
    quench_group(x) = revin_group(vgroup("[3] Reverb State",x));

    nonl = nonl_group(hslider("[style:knob] [tooltip: nonlinear mode coupling]",
        0, -0.999, 0.999, 0.001));
    loopgainmax = 1.0-0.5*quench_group(button("[1] Quench
        [tooltip: Hold down 'Quench' to clear the reverberator]"));

    pathmin = path_group(hslider("[1] min acoustic ray length [unit:m] [scale:log]
    [tooltip: This length (in meters) determines the shortest delay-line used in the FDN
    reverberator. Think of it as the shortest wall-to-wall separation in the room.]",
    46, 0.1, 63, 0.1));
    pathmax = path_group(hslider("[2] max acoustic ray length [unit:m] [scale:log]
        [tooltip: This length (in meters) determines the longest delay-line used in the
        FDN reverberator. Think of it as the largest wall-to-wall separation in the room.]",
    63, 0.1, 63, 0.1));

    durvals(i) = t60_group(vslider("[%i] %i [unit:s] [scale:log][tooltip: T60 is the 60dB
        decay-time in seconds. For concert halls, an overall reverberation time (T60) near
        1.9 seconds is typical [Beranek 2004]. Here we may set T60 independently in each
        frequency band. In real rooms, higher frequency bands generally decay faster due
        to absorption and scattering.]",ba.take(i+1,defdurs), 0.1, 100, 0.1));
    durs = par(i,NB,durvals(NB-1-i));

    freqvals(i) = freq_group(hslider("[%i] Band %i upper edge in Hz [unit:Hz] [scale:log]
    [tooltip: Each delay-line signal is split into frequency-bands for separate
    decay-time control in each band]",ba.take(i+1,deffreqs), 100, 10000, 1));
    freqs = par(i,NB-1,freqvals(i));

    delays = de.prime_power_delays(N,pathmin,pathmax);

    gain = hslider("[3] Output Level (dB) [unit:dB][tooltip: Output scale factor]",
        -40, -70, 20, 0.1) : ba.db2linear;
    // (can cause infinite loop:) with { db2linear(x) = pow(10, x/20.0); };
};

//---------------------------`(dm.)zita_rev_fdn_demo`------------------------------
// Reverb demo application based on `zita_rev_fdn`.
//
// #### Usage
//
// ```
// si.bus(8) : zita_rev_fdn_demo : si.bus(8)
// ```
//------------------------------------------------------------
declare zita_rev_fdn_demo author "Julius O. Smith III";
declare zita_rev_fdn_demo licence "MIT";

zita_rev_fdn_demo = re.zita_rev_fdn(f1,f2,t60dc,t60m,fsmax)
with{
    fsmax = 48000.0;
    fdn_group(x) = hgroup("Zita_Rev Internal FDN Reverb [tooltip: ~ Zita_Rev's internal
        8x8 Feedback Delay Network (FDN) & Schroeder allpass-comb reverberator.     See
        Faust's reverbs.lib for documentation and references]",x);
    t60dc = fdn_group(vslider("[1] Low RT60 [unit:s] [style:knob][style:knob]
    [tooltip: T60 = time (in seconds) to decay 60dB in low-frequency band]",
    3, 1, 8, 0.1));
    f1 = fdn_group(vslider("[2] LF X [unit:Hz] [style:knob] [scale:log]
    [tooltip: Crossover frequency (Hz) separating low and middle frequencies]",
    200, 50, 1000, 1));
    t60m = fdn_group(vslider("[3] Mid RT60 [unit:s] [style:knob] [scale:log]
    [tooltip: T60 = time (in seconds) to decay 60dB in middle band]",
    2, 1, 8, 0.1));
    f2 = fdn_group(vslider("[4] HF Damping [unit:Hz] [style:knob] [scale:log]
    [tooltip: Frequency (Hz) at which the high-frequency T60 is half the middle-band's T60]",
    6000, 1500, 0.49*fsmax, 1));
};

//---------------------------`(dm.)zita_light`------------------------------
// Light version of `dm.zita_rev1` with only 2 UI elements.
//
// #### Usage
//
// ```
// _,_ : zita_light : _,_
// ```
//------------------------------------------------------------
declare zita_light author "Julius O. Smith III";
declare zita_light licence "MIT";

zita_light = hgroup("Zita Light",(_,_ <: re.zita_rev1_stereo(rdel,f1,f2,t60dc,t60m,fsmax),_,_ : 
    out_eq,_,_ : dry_wet : out_level))
with{
    fsmax = 48000.0;  // highest sampling rate that will be used
    rdel = 60;    
    f1 = 200;
    t60dc = 3;
    t60m = 2;
    f2 = 6000;
    out_eq = pareq_stereo(eq1f,eq1l,eq1q) : pareq_stereo(eq2f,eq2l,eq2q);
    pareq_stereo(eqf,eql,Q) = fi.peak_eq_rm(eql,eqf,tpbt), fi.peak_eq_rm(eql,eqf,tpbt)
    with {
        tpbt = wcT/sqrt(max(0,g)); // tan(PI*B/SR), B bw in Hz (Q^2 ~ g/4)
        wcT = 2*ma.PI*eqf/ma.SR;  // peak frequency in rad/sample
        g = ba.db2linear(eql); // peak gain
    };
    eq1f = 315;
    eq1l = 0;
    eq1q = 3;
    eq2f = 1500;
    eq2l = 0;
    eq2q = 3;
    dry_wet(x,y) = *(wet) + dry*x, *(wet) + dry*y 
    with {
        wet = 0.5*(drywet+1.0);
        dry = 1.0-wet;
    };
    drywet = vslider("[1] Wet/Dry Mix [style:knob] [tooltip: Ratio of dry and wet signal. -1 = fully wet, +1 = fully dry]",
        0,-1.0,1.0,0.01) : si.smoo;
    gain = vslider("[2] Level [unit:dB] [style:knob] [tooltip: Output scale
        factor]", -6, -70, 40, 0.1) : ba.db2linear : si.smoo;
    out_level = *(gain),*(gain);
};

//----------------------------------`(dm.)zita_rev1`------------------------------
// Example GUI for `zita_rev1_stereo` (mostly following the Linux `zita-rev1` GUI).
//
// Only the dry/wet and output level parameters are "dezippered" here. If
// parameters are to be varied in real time, use `smooth(0.999)` or the like
// in the same way.
//
// #### Usage
//
// ```
// _,_ : zita_rev1 : _,_
// ```
//
// #### Reference
//
// <http://www.kokkinizita.net/linuxaudio/zita-rev1-doc/quickguide.html>
//------------------------------------------------------------
declare zita_rev1 author "Julius O. Smith III";
declare zita_rev1 licence "MIT";

zita_rev1 = _,_ <: re.zita_rev1_stereo(rdel,f1,f2,t60dc,t60m,fsmax),_,_ : out_eq,_,_ :
    dry_wet : out_level
with{
    fsmax = 48000.0;  // highest sampling rate that will be used

    fdn_group(x) = hgroup(
    "[0] Zita_Rev1 [tooltip: ~ ZITA REV1 FEEDBACK DELAY NETWORK (FDN) & SCHROEDER
    ALLPASS-COMB REVERBERATOR (8x8). See Faust's reverbs.lib for documentation and
    references]", x);

    in_group(x) = fdn_group(hgroup("[1] Input", x));

    rdel = in_group(vslider("[1] In Delay [unit:ms] [style:knob] [tooltip: Delay in ms
        before reverberation begins]",60,20,100,1));

    freq_group(x) = fdn_group(hgroup("[2] Decay Times in Bands (see tooltips)", x));

    f1 = freq_group(vslider("[1] LF X [unit:Hz] [style:knob] [scale:log] [tooltip:
        Crossover frequency (Hz) separating low and middle frequencies]", 200, 50, 1000, 1));

    t60dc = freq_group(vslider("[2] Low RT60 [unit:s] [style:knob] [scale:log]
    [style:knob] [tooltip: T60 = time (in seconds) to decay 60dB in low-frequency band]",
    3, 1, 8, 0.1));

    t60m = freq_group(vslider("[3] Mid RT60 [unit:s] [style:knob] [scale:log] [tooltip:
        T60 = time (in seconds) to decay 60dB in middle band]",2, 1, 8, 0.1));

    f2 = freq_group(vslider("[4] HF Damping [unit:Hz] [style:knob] [scale:log]
    [tooltip: Frequency (Hz) at which the high-frequency T60 is half the middle-band's T60]",
    6000, 1500, 0.49*fsmax, 1));

    out_eq = pareq_stereo(eq1f,eq1l,eq1q) : pareq_stereo(eq2f,eq2l,eq2q);
    // Zolzer style peaking eq (not used in zita-rev1) (filters.lib):
    // pareq_stereo(eqf,eql,Q) = peak_eq(eql,eqf,eqf/Q), peak_eq(eql,eqf,eqf/Q);
    // Regalia-Mitra peaking eq with "Q" hard-wired near sqrt(g)/2 (filters.lib):
    pareq_stereo(eqf,eql,Q) = fi.peak_eq_rm(eql,eqf,tpbt), fi.peak_eq_rm(eql,eqf,tpbt)
    with {
        tpbt = wcT/sqrt(max(0,g)); // tan(PI*B/SR), B bw in Hz (Q^2 ~ g/4)
        wcT = 2*ma.PI*eqf/ma.SR;  // peak frequency in rad/sample
        g = ba.db2linear(eql); // peak gain
    };

    eq1_group(x) = fdn_group(hgroup("[3] RM Peaking Equalizer 1", x));

    eq1f = eq1_group(vslider("[1] Eq1 Freq [unit:Hz] [style:knob] [scale:log] [tooltip:
        Center-frequency of second-order Regalia-Mitra peaking equalizer section 1]",
    315, 40, 2500, 1));

    eq1l = eq1_group(vslider("[2] Eq1 Level [unit:dB] [style:knob] [tooltip: Peak level
        in dB of second-order Regalia-Mitra peaking equalizer section 1]", 0, -15, 15, 0.1));

    eq1q = eq1_group(vslider("[3] Eq1 Q [style:knob] [tooltip: Q = centerFrequency/bandwidth
        of second-order peaking equalizer section 1]", 3, 0.1, 10, 0.1));

    eq2_group(x) = fdn_group(hgroup("[4] RM Peaking Equalizer 2", x));

    eq2f = eq2_group(vslider("[1] Eq2 Freq [unit:Hz] [style:knob] [scale:log] [tooltip:
        Center-frequency of second-order Regalia-Mitra peaking equalizer section 2]",
    1500, 160, 10000, 1));

    eq2l = eq2_group(vslider("[2] Eq2 Level [unit:dB] [style:knob] [tooltip: Peak level
        in dB of second-order Regalia-Mitra peaking equalizer section 2]", 0, -15, 15, 0.1));

    eq2q = eq2_group(vslider("[3] Eq2 Q [style:knob] [tooltip: Q = centerFrequency/bandwidth
        of second-order peaking equalizer section 2]", 3, 0.1, 10, 0.1));

    out_group(x) = fdn_group(hgroup("[5] Output", x));

    dry_wet(x,y) = *(wet) + dry*x, *(wet) + dry*y with {
        wet = 0.5*(drywet+1.0);
        dry = 1.0-wet;
    };

    drywet = out_group(vslider("[1] Wet/Dry Mix [style:knob] [tooltip: Ratio of dry and wet signal. -1 = fully wet, +1 = fully dry]",
    0, -1.0, 1.0, 0.01)) : si.smoo;

    out_level = *(gain),*(gain);

    gain = out_group(vslider("[2] Level [unit:dB] [style:knob] [tooltip: Output scale
        factor]", -20, -70, 40, 0.1)) : ba.db2linear : si.smoo;
};


//----------------------------------`(dm.)vital_rev_demo`------------------------------
// Example GUI for `vital_rev` with all parameters exposed.
//
// #### Usage
//
// ```
// _,_ : vital_rev_demo : _,_
// ```
//
//------------------------------------------------------------
vital_rev_demo = hgroup("Reverb", re.vital_rev(prelow, prehigh, lowcutoff, highcutoff, lowgain, highgain, chorus_amt, chorus_freq, predelay, time, size, mix))
with {
    // SMOO = _; 
    SMOO = si.smoo; // optionally turn on smoo of hsliders

    Prefilter(x) = hgroup("[0] Pre-filter", x:SMOO);
    Filter(x) = hgroup("[1] Filter", x:SMOO);
    Chorus(x) = hgroup("[2] Chorus", x:SMOO);
    Space(x) = hgroup("[3] Space", x:SMOO);

    prelow = Prefilter(hslider("[0] Low Cutoff [style:knob]", it.remap(16,135,0,1,16), 0, 1, .01));
    prehigh = Prefilter(hslider("[1] High Cutoff [style:knob]", it.remap(16,135,0,1,110), 0, 1, .01));

    lowcutoff = Filter(hslider("[0] Low Shelf [style:knob]", it.remap(16,135,0,1,16), 0, 1, .01));
    highcutoff = Filter(hslider("[2] High Shelf [style:knob]", it.remap(16,135,0,1,90), 0, 1, .01));

    lowgain = Filter(hslider("[1] Low Gain [style:knob]", it.remap(-6,0,0,1,0), 0, 1, .01));
    highgain = Filter(hslider("[3] High Gain [style:knob]", it.remap(-6,0,0,1,-1), 0, 1, .01));

    chorus_amt = Chorus(hslider("[0] Amount [style:knob]", .01, 0, 1, .01));
    chorus_freq = Chorus(hslider("[1] Rate [style:knob]", 0.1, 0, 1, .01));

    predelay = Space(hslider("[0] Pre-Delay [style:knob]", 0, 0, 1, .01));
    time = Space(hslider("[1] Decay Time [style:knob]", 0.5, 0, 1, .01));
    size = Space(hslider("[2] Size [style:knob]", .5, 0, 1, .01)) : aa.clip(0, 1);

    mix = hslider("[4] Mix [style:knob]",  1, 0, 1, .01) : SMOO : aa.clip(0, 1);
};
declare vital_rev_demo author "David Braun";
declare vital_rev_demo license "GPL-3.0";


//--------------------------`(dm.)reverbTank_demo`---------------------------
//
// This is a stereo reverb following the "ReverbTank" example in [1],
// although some parameter ranges and scaling have been adjusted.
// It is an unofficial version of the Spin Semiconductor® Reverb.
// Other relevant instructional material can be found in [2-4].
//
// #### Usage
// ```
// _,_ : reverbTank_demo : _,_
// ```
//
// #### References
// * [1] Pirkle, W. C. (2019). Designing audio effect plugins in C++ (2nd ed.). Chapter 17.14.
//
// * [2] Spin Semiconductor. (n.d.). Reverberation. Retrieved 2024-04-16, from <http://www.spinsemi.com/knowledge_base/effects.html#Reverberation>
//
// * [3] Zölzer, U. (2022). Digital audio signal processing (3rd ed.). Chapter 7, Figure 7.39.
//
// * [4] Valhalla DSP. (2010, August 25). RIP Keith Barr. Retrieved 2024-04-16, from <https://valhalladsp.com/2010/08/25/rip-keith-barr/>
//-----------------------------------------------------------------------
reverbTank_demo = hgroup("Reverb", ef.dryWetMixer(wet, 
    (preDelay : preFilter : avg : ((si.bus(2) :> branches) ~ selectLastBranchDelay) : selectLR :> shelves)
))
with {
    /*
    All-capitalized signals are compile-time constant.
    All other signals can be modulated in real-time, although you may not necessarily want to modulate them.
    */

    // SMOO = _; // If you don't want to smooth parameters.
    SMOO = si.smoo;

    PRE_DELAY_MAX_MSEC = 100;
    OUTER_DELAY_MAX_MSEC = 100;
    INNER_DELAY_MAX_MSEC = 100;
    FIXED_DELAY_MAX_MSEC = 100;

    OUTER_DELAY_MAX_SAMPS = OUTER_DELAY_MAX_MSEC : msec2samp;
    INNER_DELAY_MAX_SAMPS = INNER_DELAY_MAX_MSEC : msec2samp;
    FIXED_DELAY_MAX_SAMPS = FIXED_DELAY_MAX_MSEC : msec2samp;

    enableLFO = 1; // set to zero if you don't want LFO, which is used for the chorus
    LFO_MAX_MODULATION_MS = 0.3;

    outerG = 0.5;
    innerG = -outerG;
    lfoRates = 0.15, 0.33, 0.57, 0.73; // [NUM_BRANCHES]. Measured in Hz

    // Note that fixedDelayWeights and apfDelayWeights are not volume weights.
    // They get multiplied by globalFixedMaxDelay and globalAPFMaxDelay respectively
    // to current tap lengths (for the fixed delays) and current delays (for APF delays).

    // Note that if you turn `fixedDelayWeights` into something changing in real-time,
    // then you need to remove an optimization related to `DELAY_MAX_SAMPS` in `multiTapDelay`
    fixedDelayWeights = 1.0, 0.873, 0.707, 0.667;  // [NUM_BRANCHES]

    // Thick mode:
    TAPS_PER_BRANCH = 2;
    tapPctsLeft = 23, 31, 41, 47, 59, 67, 73, 83;  // [NUM_TAPS]
    tapPctsRght = 29, 37, 43, 53, 61, 71, 79, 89;  // [NUM_TAPS]
    apfDelayWeights = 0.317, 0.873, 0.477, 0.291, 0.993, 0.757, 0.179, 0.575;  // [NUM_TAPS]

    // Sparse mode:
    // TAPS_PER_BRANCH = 1;
    // tapPctsLeft = (23, 41, 59, 73);  // [NUM_TAPS]
    // tapPctsRght = (29, 43, 61, 79);  // [NUM_TAPS]
    // apfDelayWeights = 0.317, 0.873, 0.477, 0.291;  // [NUM_TAPS]

    NUM_BRANCHES = 4;
    NUM_TAPS = NUM_BRANCHES * TAPS_PER_BRANCH;

    PreUI(x) = hgroup("[0] Pre", x:SMOO);
    DelayUI(x) = hgroup("[1] Delay", x:SMOO);
    Filter(x) = hgroup("[2] Post-Filter", x:SMOO);
    wet = hslider("[3] Wet [style:knob]", 1, 0, 1, .01) : SMOO;

    preDelayTime = PreUI(hslider("[0] Delay [style:knob][unit:ms]", 0, 0, PRE_DELAY_MAX_MSEC, 1)) : msec2samp;
    preFilterCutoff = PreUI(hslider("[1] LPF Cutoff [style:knob][unit:KHz]", 16, 1, 20, .1))*1000;

    globalAPFMaxDelay = DelayUI(hslider("[0] APF Delay [style:knob][unit:ms]", 33*.85, 0, INNER_DELAY_MAX_MSEC, .01)) : msec2samp;
    globalFixedMaxDelay = DelayUI(hslider("[1] Fixed Delay [style:knob][unit:ms]", 81.0, 0, OUTER_DELAY_MAX_MSEC, .01)) : msec2samp;
    kRT = DelayUI(hslider("[2] Reverb Time [style:knob]", .5, 0, 1, .01)) : it.remap(0, 1, -72, -6) : ba.db2linear;
    lfoDepth = DelayUI(hslider("[3] LFO Depth [style:knob][unit:ms]", LFO_MAX_MODULATION_MS*.1, 0, LFO_MAX_MODULATION_MS, .01)) : msec2samp;
    lpfCutoff = DelayUI(hslider("[4] LPF Cutoff [style:knob][unit:KHz]", 15, 1, 20, .1))*1000;

    lowCutoffFrequency = Filter(hslider("[0] Low Shelf [style:knob][unit:midi]", 16, 16, 135, .1)) : aa.clip(16, 135) : ba.midikey2hz;
    highCutoffFrequency = Filter(hslider("[2] High Shelf [style:knob][unit:midi]", 90, 16, 135, .1)) : aa.clip(16, 135) : ba.midikey2hz;
    lowGain = Filter(hslider("[1] Low Gain [style:knob][unit:dB]", -20, -20, 20, .1)) : aa.clip(-20, 20);
    highGain = Filter(hslider("[3] High Gain [style:knob][unit:dB]", -6, -20, 20, .1)) : aa.clip(-20, 20);

    msec2samp(ms) = ms*ma.SR/1000; 

    // -------------`nestedDelayAPF`-----------------
    // Nested Allpass Filter, as described in [1].
    // The user can pass an `outerDelay` function whose delay length
    // is modulated by an LFO. The user can also put an LTI filter such
    // as a low-pass filter on the outerDelay function.
    //
    // #### Usage
    // ```
    // _ : nestedDelayAPF(outerDelay, MAXLEN, curDel, outerG, innerG) : _
    // ```
    // Where:
    // * `outerDelay`: a delay function with one input and one output
    // * `MAXLEN`: constant maximum delay in samples of the inner allpass filter
    // * `curDel`: current delay in samples of the inner allpass filter
    // * `outerG`: allpass minus-gain coefficient [-1..1]
    // * `innerG`: allpass minus-gain coefficient [-1..1]
    //
    // #### References
    // [1] Pirkle, W. C. (2019). Designing audio effect plugins in C++ (2nd ed.). Chapter 17.13.17.
    //------------------------------------------------------------
    nestedDelayAPF(outerDelay, MAXLEN, curDel, outerG, innerG) =
    (+ <: (innerAPF:outerDelay),*(outerG)) ~ *(-outerG) : mem,_ : +
    with {
        innerAPF = fi.allpass_fcomb(MAXLEN, curDel, innerG);
    };

    // inputs:
    // * `i`: the branch index
    // * `x`: input signal (sum of pre-delay and output of previous branch)
    //
    // outputs:
    // * `i`: previous branch index plus 1
    // * `preBranchSig`: passthrough preBranchSig
    // * Delayed value to be used for next branch
    // * Sum of left channel tap(s)
    // * Sum of right channel tap(s)
    branch(i, x) = x : nestedAllpass : lpf : multiTapDelay
    with {
        nestedAllpass = nestedDelayAPF(outerDelay, INNER_DELAY_MAX_SAMPS, innerDelaySamps, outerG, innerG)
        with {
            outerDelay = lpf : de.fdelayltv(DELAY_ORDER, OUTER_DELAY_MAX_SAMPS, safeDelaySamps) // todo: is fdelayltv worth it?
            with {
                DELAY_ORDER = 2;
                minDelaySamps = (DELAY_ORDER-1)/2;
                delaySampsWithLFO = os.osc(lfoRate) : it.remap(-1, 1, outerDelaySamps, max(minDelaySamps, outerDelaySamps-lfoDepth));
                safeDelaySamps = ba.if(enableLFO, delaySampsWithLFO, outerDelaySamps) : max(minDelaySamps);
            };
            outerDelaySamps = globalAPFMaxDelay*(ba.selectn(NUM_TAPS, i*2  , apfDelayWeights));
            innerDelaySamps = globalAPFMaxDelay*(ba.selectn(NUM_TAPS, i*2+1, apfDelayWeights));
            lfoRate = ba.selectn(NUM_BRANCHES, i, lfoRates);
        };
        // note that the same LPF is used in two places (inside the nested APF and outside it but in the branch)
        lpf = fi.lowpass(1, lpfCutoff);

        // Here we rely on Faust's compiler to only use one delay line!
        multiTapDelay = _ <: delayLine(fixedDelaySamps)*kRT, getChannel(0), getChannel(1)
        with {
            // Note that we use fdelaylti instead of fdelayltv because we assume the delay lengths
            // aren't being changed rapidly
            delayLine(delaySamps) = de.fdelaylti(DELAY_ORDER, DELAY_MAX_SAMPS, safeDelaySamps)
            with {
                // If `fixedDelayWeights` is constant then we can use this memory optimization:
                DELAY_MAX_SAMPS = OUTER_DELAY_MAX_SAMPS*fixedDelayWeight;
                // Otherwise, we'd have to use this:
                // DELAY_MAX_SAMPS = FIXED_DELAY_MAX_SAMPS;

                DELAY_ORDER = 2;
                safeDelaySamps = max(delaySamps, (DELAY_ORDER-1)/2);
            };

            fixedDelayWeight = ba.selectn(NUM_BRANCHES, i, fixedDelayWeights);
            fixedDelaySamps = globalFixedMaxDelay*fixedDelayWeight;

            getChannel(c) = sum(k, TAPS_PER_BRANCH, getTap(c, k));
            // Note that the tap positions scale with fixedDelaySamps rather than globalFixedMaxDelay or OUTER_DELAY_MAX_SAMPS
            getTap(c, k) = delayLine(fixedDelaySamps*delayPct) * ((-1)^(i+c))
            with {
                delayPct = tap_left, tap_rght : select2(c) : _/100
                with {
                    tap_left = ba.selectn(NUM_TAPS, i*TAPS_PER_BRANCH+k, tapPctsLeft);
                    tap_rght = ba.selectn(NUM_TAPS, i*TAPS_PER_BRANCH+k, tapPctsRght);
                };
            };
        };
    };

    repeatpar(1, FX) = FX;
    repeatpar(n, FX) = FX <: (si.bus(iC), si.block(oC-iC):repeatpar(n-1, FX)), si.bus(oC)
    with {
        iC = inputs(FX);
        oC = outputs(FX);
    };

    branches = (0, _, 0 : repeatpar(NUM_BRANCHES, fx)) : keepBranchChannels
    with {
        // inputs:
        // * `i`: branch index, starting at 0
        // * `x`: the signal before all of the branches
        // * `y`: the delayed signal from the previous branch, if any
        //
        // outputs:
        // * increment `i` so that the next fx has i+1 in the same arg slot
        // * passthrough `x` so it stays as the signal before all of the branches
        // * the output(s) of the next branch, by passing `x+y` as input
        fx(i, x, y) = i+1, x, branch(i, x+y);

        // For each branch, cut the integer `i` and `x` channels, but keep the remaining channels:
        // * the local branch's "delayed" output
        // * the left tap(s)
        // * the right tap(s)
        keepBranchChannels = par(b, NUM_BRANCHES, (!, !, si.bus(outputs(fx)-2)));
    };

    // use fdelaylti instead of fdelayltv because the user probably isn't changing the predelay quickly
    preDelay = sp.stereoize(de.fdelaylti(DELAY_ORDER, preDelayMaxSamp, safeDelaySamps))
    with {
        DELAY_ORDER = 1;
        safeDelaySamps = max(preDelayTime, (DELAY_ORDER-1)/2);
        preDelayMaxSamp = PRE_DELAY_MAX_MSEC : msec2samp;
    };
    preFilter = sp.stereoize(fi.lowpass(1, preFilterCutoff));
    avg = _,_:> _*.5;
    selectLastBranchDelay = ba.selector(0, 3*NUM_BRANCHES);
    selectLR = par(i, NUM_BRANCHES, (!, _, _)); // for each branch, cut the "delayed" output and keep the left-right outputs
    shelves = sp.stereoize(_/NUM_TAPS:(fi.lowshelf(1, lowGain, lowCutoffFrequency) : fi.highshelf(1, highGain, highCutoffFrequency)));
};

declare reverbTank_demo author "David Braun";
declare reverbTank_demo copyright "Copyright (C) 2024 by David Braun <braun@ccrma.stanford.edu>";
declare reverbTank_demo license "MIT-style STK-4.3 license";


//--------------------------`(dm.)kb_rom_rev1_demo`--------------------------
// Keith Barr reverb effect rom_rev1 demo application.
//
// #### Usage
//
// ```
// _,_ : kb_rom_rev1_demo : _,_
// ```
//------------------------------------------------------------
declare kb_rom_rev1_demo author "Luca Spanedda";
declare kb_rom_rev1_demo licence "GPL-3.0";

kb_rom_rev1_demo = hgroup("Reverb", dryWetMix(re.kb_rom_rev1(rt, damp)))
with {
    // Smooth
    SMOO = si.smoo; 
    // GUI sections
    Filter(x) = hgroup("[1] Filter", x:SMOO);
    Space(x) = hgroup("[0] Space", x:SMOO);
    Output(x) = hgroup("[2] Output", x:SMOO);
    // GUI controls
    rt =   Space(hslider("[0] Decay Time [style:knob]", 0.8, 0.0, 1.0, 0.001));
    damp = 1 - Filter(hslider("[1] High Cutoff [style:knob]", 0.5, 0.0, 1.0, 0.001));
    drywet(x) = Output(abs(x - vslider("[2] Dry/Wet Mix [style:knob]", 1, 0.0, 1.0, 0.001)));
    // Dry/Wet mixer
    dryWetMix(x) = si.bus(2) <: ((x : par(i, 2, _ * drywet(0))), par(i, 2, _ * drywet(1))) :> si.bus(2);
};


//----------------------------------`(dm.)dattorro_rev_demo`------------------------------
// Example GUI for `dattorro_rev` with all parameters exposed and additional
// dry/wet and output gain control.
//
// #### Usage
//
// ```
// _,_ : dattorro_rev_demo : _,_
// ```
//
//------------------------------------------------------------
declare dattorro_rev_demo author "Jakob Zerbian";
declare dattorro_rev_demo license "MIT-style STK-4.3 license";

dattorro_rev_demo = _,_ <: re.dattorro_rev(pre_delay, bw, i_diff1, i_diff2, decay, d_diff1, d_diff2, damping),_,_:
    dry_wet : out_level
with {
    rev_group(x) = hgroup("[0] Dattorro Reverb",x);

    in_group(x) = rev_group(hgroup("[0] Input",x));
    pre_delay = 0;
    bw = in_group(vslider("[1] Prefilter [style:knob] [tooltip: lowpass-like filter, 0 = no signal, 1 = no filtering]",0.7,0.0,1.0,0.001) : si.smoo);
    i_diff1 = in_group(vslider("[2] Diffusion 1 [style:knob] [tooltip: diffusion factor, influences reverb color and density]",0.625,0.0,1.0,0.001) : si.smoo);
    i_diff2 = in_group(vslider("[3] Diffusion 2 [style:knob] [tooltip: diffusion factor, influences reverb color and density]",0.625,0.0,1.0,0.001) : si.smoo);

    fdb_group(x) = rev_group(hgroup("[1] Feedback",x));
    d_diff1 = fdb_group(vslider("[1] Diffusion 1 [style:knob] [tooltip: diffusion factor, influences reverb color and density]",0.625,0.0,1.0,0.001) : si.smoo);
    d_diff2 = fdb_group(vslider("[2] Diffusion 2 [style:knob] [tooltip: diffusion factor, influences reverb color and density]",0.625,0.0,1.0,0.001) : si.smoo);
    decay = fdb_group(vslider("[3] Decay Rate [style:knob] [tooltip: decay length, 1 = infinite]",0.7,0.0,1.0,0.001) : si.smoo);
    damping = fdb_group(vslider("[4] Damping [style:knob] [tooltip: dampening in feedback network]",0.625,0.0,1.0,0.001) : si.smoo);

    out_group(x) = rev_group(hgroup("[2] Output",x));
    dry_wet(x,y) = *(dry) + wet*x, *(dry) + wet*y 
    with {
        wet = 0.5*(drywet+1.0);
        dry = 1.0-wet;
    };
    drywet = out_group(vslider("[1] Dry/Wet Mix [style:knob] [tooltip: -1 = dry, 1 = wet]",0,-1.0,1.0,0.01) : si.smoo);
    gain = out_group(vslider("[2] Level [unit:dB] [style:knob] [tooltip: Output Gain]", -6, -70, 40, 0.1) : ba.db2linear : si.smoo);
    out_level = *(gain),*(gain);
};

//----------------------------------`(dm.)jprev_demo`------------------------------
// Example GUI for `jprev` with all parameters exposed. 
//
// #### Usage
//
// ```
// _,_ : jprev_demo : _,_
// ```
//
//------------------------------------------------------------
declare jprev_demo author "Till Bovermann";
declare jprev_demo license "GPL2+";

jprev_demo = re.jpverb(t60, damp, size, early_diff, mod_depth, mod_freq, low, mid, high, low_cutoff, high_cutoff)
with {
    rev_group(x) = vgroup("[0] JPrev",x);
    invSqrt2 = 1/sqrt(2);
    mix_group(x) = rev_group(hgroup("[0] Mix",x));
    early_diff = mix_group(hslider("[1]earlyDiff [style:knob]", invSqrt2, 0, 0.990, 0.001));
    size = mix_group(hslider("[2]size [style:knob]", 1, 0.5, 3, 0.01));
    t60 = mix_group(hslider("[3]t60 [style:knob]", 1, 0.1, 60, 0.1));
    damp = mix_group(hslider("[4]damp [style:knob]", 0, 0, 0.999, 0.0001));
    
    eq_group(x) = rev_group(hgroup("[1] EQ",x));
    low = eq_group(hslider("[07]lowX [style:knob]", 1, 0, 1, 0.01));
    mid = eq_group(hslider("[08]midX [style:knob]", 1, 0, 1, 0.01));
    high = eq_group(hslider("[09]highX [style:knob]", 1, 0, 1, 0.01));
    low_cutoff = eq_group(hslider("[10]lowBand [style:knob]", 500, 100, 6000, 0.1));
    high_cutoff = eq_group(hslider("[11]highBand [style:knob]", 2000, 1000, 10000, 0.1));
    
    mod_group(x) = rev_group(hgroup("[2] Mod",x));
    mod_depth = mod_group(hslider("[1]mDepth [style:knob]", 0.1, 0, 1, 0.001));
    mod_freq = mod_group(hslider("[2]mFreq [style:knob]", 2, 0, 10, 0.010));  
};


//----------------------------------`(dm.)greyhole_demo`------------------------------
// Example GUI for `greyhole` with all parameters exposed. 
//
// #### Usage
//
// ```
// _,_ : greyhole_demo : _,_
// ```
//
//------------------------------------------------------------
declare greyhole_demo author "Till Bovermann";
declare greyhole_demo license "GPL2+";

greyhole_demo = re.greyhole(dt, damp, size, early_diff, feedback, mod_depth, mod_freq)
with {

    rev_group(x) = vgroup("[0] Greyhole",x);
    
    mix_group(x) = rev_group(hgroup("[0] Mix",x));
    dt = mix_group(hslider("[01]delayTime [style:knob]", 0.2, 0.001, 1.45, 0.0001));
    damp = mix_group(hslider("[02]damping [style:knob]", 0, 0, 0.99, 0.001));
    size = mix_group(hslider("[03]size [style:knob]", 1, 0.5, 3, 0.0001));
    early_diff = mix_group(hslider("[04]diffusion [style:knob]", 0.5, 0, 0.99, 0.0001));
    feedback = mix_group(hslider("[05]feedback [style:knob]", 0.9, 0, 1, 0.01));
    
    mod_group(x) = rev_group(hgroup("[1] Mod",x));
    mod_depth = mod_group(hslider("[06]modDepth [style:knob]", 0.1, 0, 1, 0.001));
    mod_freq = mod_group(hslider("[07]modFreq [style:knob]", 2, 0, 10, 0.01));
};

//====================================Generators==========================================
//========================================================================================

//--------------------------`(dm.)sawtooth_demo`---------------------------
// An application demonstrating the different sawtooth oscillators of Faust.
//
// #### Usage
//
// ```
// sawtooth_demo : _
// ```
//------------------------------------------------------------
declare sawtooth_demo author "Julius O. Smith III";
declare sawtooth_demo licence "MIT";

sawtooth_demo = signal
with{
    osc_group(x) = vgroup("[0] SAWTOOTH OSCILLATOR [tooltip: See Faust's oscillators.lib
        for documentation and references]",x);
    knob_group(x)  = osc_group(hgroup("[1]", x));
    ampdb  = knob_group(vslider("[1] Amplitude [unit:dB] [style:knob] [tooltip: Sawtooth
        waveform amplitude]",-20,-120,10,0.1));
    amp = ampdb : ba.db2linear : si.smoo;
    freq = knob_group(vslider("[2] Frequency [unit:PK] [style:knob] [tooltip: Sawtooth
        frequency as a Piano Key (PK) number (A440 = key 49)]",49,1,88,0.01) : ba.pianokey2hz);
    detune1 = 1 + 0.01 * knob_group(
    vslider("[3] Detuning 1 [unit:%%] [style:knob] [tooltip: Percentage frequency-shift
    up or down for second oscillator]",-0.1,-10,10,0.01));
    detune2 = 1 + 0.01 * knob_group(vslider("[4] Detuning 2 [unit:%%] [style:knob] [tooltip:
        Percentage frequency-shift up or down for third detuned oscillator]",+0.1,-10,10,0.01));
    portamento = knob_group(vslider("[5] Portamento [unit:sec] [style:knob] [scale:log]
    [tooltip: Portamento (frequency-glide) time-constant in seconds]",0.1,0.001,10,0.001));
    sfreq = freq : si.smooth(ba.tau2pole(portamento));
    saworder = knob_group(nentry("[6] Saw Order [tooltip: Order of sawtootn aliasing
        suppression]",2,1,os.MAX_SAW_ORDER,1));
    sawchoice = _ <: par(i,os.MAX_SAW_ORDER,os.sawN(i+1)) :
        ba.selectn(int(os.MAX_SAW_ORDER), int(saworder-1)); // when max is pwr of 2
    tone = (amp/3) * (sawchoice(sfreq) + sawchoice(sfreq*detune1) + sawchoice(sfreq*detune2));
    signal = amp * select2(ei, select2(ss, tone, white_or_pink_noise), _);
    white_or_pink_noise = select2(wp,no.noise,no.pink_noise);
    checkbox_group(x) = knob_group(vgroup("[7] Alternate Signals",x));
    ss = checkbox_group(checkbox("[0] Noise (White or Pink - uses only Amplitude control on
        the left)"));
    wp = checkbox_group(checkbox("[1] Pink instead of White Noise (also called 1/f Noise)
        [tooltip: Pink Noise (or 1/f noise) is Constant-Q Noise, meaning that it has the
        same total power in every octave]"));
    ei = checkbox_group(checkbox("[2] External Signal Input (overrides Sawtooth/Noise
        selection above)"));
};


//----------------------`(dm.)virtual_analog_oscillator_demo`----------------------
// Virtual analog oscillator demo application.
//
// #### Usage
//
// ```
// virtual_analog_oscillator_demo : _
// ```
//------------------------------------------------------------
declare virtual_analog_oscillator_demo author "Julius O. Smith III";
declare virtual_analog_oscillator_demo licence "MIT";

virtual_analog_oscillator_demo = signal
with{
    osc_group(x) = vgroup("[0] VIRTUAL ANALOG OSCILLATORS
        [tooltip: See Faust's oscillators.lib for documentation and references]",x);

    // Signals
    sawchoice = _ <:
    // When MAX_SAW_ORDER is a power of 2:
    par(i,os.MAX_SAW_ORDER,os.sawN(i+1)) : ba.selectn(int(os.MAX_SAW_ORDER), int(saworder-1));
    // When MAX_SAW_ORDER is NOT a power of 2:
    // (par(i,MAX_SAW_ORDER,sawN(i+1)), par(j,MAX_SAW_ORDER_NEXTPOW2-MAX_SAW_ORDER,_))
    //   : selectn(MAX_SAW_ORDER_NEXTPOW2, saworder-1);
    saw = (amp/3) *
        (sawchoice(sfreq) + sawchoice(sfreq*detune1) + sawchoice(sfreq*detune2));
    sq = (amp/3) *
    (os.square(sfreq) + os.square(sfreq*detune1) + os.square(sfreq*detune2));
    tri = (amp/3) *
    (os.triangle(sfreq) + os.triangle(sfreq*detune1) + os.triangle(sfreq*detune2));
    pt = (amp/3) * (os.pulsetrain(sfreq,ptd)
            + os.pulsetrain(sfreq*detune1,ptd)
            + os.pulsetrain(sfreq*detune2,ptd));
    ptN = (amp/3) * (os.pulsetrainN(N,sfreq,ptd)
            + os.pulsetrainN(N,sfreq*detune1,ptd)
            + os.pulsetrainN(N,sfreq*detune2,ptd)) with { N=3; };
    pn = amp * no.pink_noise;

    signal = ssaw*saw + ssq*sq + stri*tri
           + spt*((ssptN*ptN)+(1-ssptN)*pt)
           + spn*pn + sei*_;

    // Signal controls:
    signal_group(x) = osc_group(hgroup("[0] Signal Levels",x));
    ssaw = signal_group(vslider("[0] Sawtooth [style:vslider]",1,0,1,0.01));

    pt_group(x) = signal_group(vgroup("[1] Pulse Train",x));
    ssptN = pt_group(checkbox("[0] Order 3
        [tooltip: When checked, use 3rd-order aliasing suppression (up from 2)
    See if you can hear a difference with the freq high and swept]"));
    spt = pt_group(vslider("[1] [style:vslider]",0,0,1,0.01));
    ptd = pt_group(vslider("[2] Duty Cycle [style:knob]",0.5,0,1,0.01))
    : si.smooth(0.99);

    ssq = signal_group(vslider("[2] Square [style:vslider]",0,0,1,0.01));
    stri = signal_group(vslider("[3] Triangle [style:vslider]",0,0,1,0.01));
    spn = signal_group(vslider(
        "[4] Pink Noise [style:vslider][tooltip: Pink Noise (or 1/f noise) is
        Constant-Q Noise, meaning that it has the same total power in every octave
        (uses only amplitude controls)]",0,0,1,0.01));
    sei = signal_group(vslider("[5] Ext Input [style:vslider]",0,0,1,0.01));

    // Signal Parameters
    knob_group(x) = osc_group(hgroup("[1] Signal Parameters", x));
    af_group(x) = knob_group(vgroup("[0]", x));
    ampdb = af_group(hslider("[1] Mix Amplitude [unit:dB] [style:hslider]
        [tooltip: Sawtooth waveform amplitude]",-20,-120,10,0.1));
    amp = ampdb : ba.db2linear : si.smoo;
    freq = af_group(hslider("[2] Frequency [unit:PK] [style:hslider] [tooltip: Sawtooth
        frequency as a Piano Key (PK) number (A440 = key 49)]",49,1,88,0.01) : ba.pianokey2hz);

    detune1 = 1 - 0.01 * knob_group(
        vslider("[3] Detuning 1 [unit:%%] [style:knob]
    [tooltip: Percentage frequency-shift up or down for second oscillator]",
    -0.1,-10,10,0.01));
    detune2 = 1 + 0.01 * knob_group(
    vslider("[4] Detuning 2 [unit:%%] [style:knob]
    [tooltip: Percentage frequency-shift up or down for third detuned oscillator]",
    +0.1,-10,10,0.01));
    portamento = knob_group(
    vslider("[5] Portamento [unit:sec] [style:knob] [scale:log]
    [tooltip: Portamento (frequency-glide) time-constant in seconds]",
    0.1,0.001,10,0.001));
    saworder = knob_group(nentry("[6] Saw Order [tooltip: Order of sawtooth aliasing
    suppression]",2,1,os.MAX_SAW_ORDER,1));
    sfreq = freq : si.smooth(ba.tau2pole(portamento));
};


//--------------------------`(dm.)oscrs_demo` ---------------------------
// Simple application demoing filter based oscillators.
//
// #### Usage
//
// ```
// oscrs_demo : _
// ```
//-------------------------------------------------------------------
declare oscrs_demo author "Julius O. Smith III";
declare oscrs_demo licence "MIT";

oscrs_demo = signal
with{
    osc_group(x) = vgroup("[0] SINE WAVE OSCILLATOR oscrs [tooltip: Sine oscillator based
        on 2D vector rotation]",x);
    ampdb  = osc_group(hslider("[1] Amplitude [unit:dB] [tooltip: Sawtooth waveform
        amplitude]",-20,-120,10,0.1));
    amp = ampdb : ba.db2linear : si.smoo;
    freq = osc_group(
        hslider("[2] Frequency [unit:PK]
    [tooltip: Sine wave frequency as a Piano Key (PK) number (A440 = 49 PK)]",
    49,1,88,0.01) : ba.pianokey2hz);
    portamento = osc_group(
    hslider("[3] Portamento [unit:sec] [scale:log]
    [tooltip: Portamento (frequency-glide) time-constant in seconds]",
    0.1,0.001,10,0.001));
    sfreq = freq : si.smooth(ba.tau2pole(portamento));
    signal = amp * os.oscrs(sfreq);
};

oscr_demo = oscrs_demo; // synonym


//--------------------------`(dm.)velvet_noise_demo`---------------------------
// Listen to velvet_noise!
//
// #### Usage
//
// ```
// velvet_noise_demo : _
// ```
//-------------------------------------------------------------------
declare velvet_noise_demo author "Julius O. Smith III";
declare velvet_noise_demo licence "MIT";

velvet_noise_demo = vn
with{
    amp = hslider("Amp [unit:dB]",-10,-70,10,0.1) : ba.db2linear;
    f0 = 10.0, hslider("Freq [unit:log10(Hz)]",3,0,4,0.001) : pow;
    vn = no.velvet_noise(amp,f0);
};


//--------------------------`(dm.)latch_demo`---------------------------
// Illustrate latch operation.
//
// #### Usage
//
// ```
// echo 'import("stdfaust.lib");' > latch_demo.dsp
// echo 'process = dm.latch_demo;' >> latch_demo.dsp
// faust2octave latch_demo.dsp
// Octave:1> plot(faustout);
// ```
//-------------------------------------------------------------------
declare latch_demo author "Julius O. Smith III";
declare latch_demo licence "MIT";

latch_demo = x, c, ba.latch(c,x) // plot(faustout) after faust2octave
with{
    f = float(ma.SR)/1000.0;
    x = os.oscr(f);
    c = 0.5 * os.oscrs(5*f); // sample 5 times per period
};


//--------------------------`(dm.)envelopes_demo`---------------------------
// Illustrate various envelopes overlaid, including their gate * 1.1.
//
// #### Usage
//
// ```
// echo 'import("stdfaust.lib");' > envelopes_demo.dsp
// echo 'process = dm.envelopes_demo;' >> envelopes_demo.dsp
// faust2octave envelopes_demo.dsp
// Octave:1> plot(faustout);
// ```
//-------------------------------------------------------------------
declare envelopes_demo author "Julius O. Smith III";
declare envelopes_demo licence "MIT";

envelopes_demo = gate <: _*1.1,envSE,envAR,envARFE,envARE,envASR,envADSR,envADSRE
with{
    gate = (1-(1@500)) + 0.5*(1@750-(1@1700)); // retrigger at 1/2 amp
    envSE    = en.smoothEnvelope(attSec/6.91); // uses time-constant not t60
    envAR    = en.ar(attSec,relT60);
    envARFE  = en.arfe(attSec,relT60,0.25);
    envARE   = en.are(attSec,relT60);
    envASR   = en.asr(attSec,susLvl,relT60);
    envADSR  = en.adsr(attSec,decT60,susLvl,relT60);
    envADSRE = en.adsre(attSec,decT60,susLvl,relT60);
    attSec=0.002; //  2 ms attack time
    decT60=0.010; // 10 ms decay-to-sustain time
    susLvl=0.80;  // Sustain level = 0.8
    relT60=0.010; // 10 ms release (decay-to-zero) time
};

//-------------------`(dm.)fft_spectral_level_demo`------------------
// Make a real-time spectrum analyzer using FFT from analyzers.lib.
//
// #### Usage
//
// ```
// echo 'import("stdfaust.lib");' > fft_spectral_level_demo.dsp
// echo 'process = dm.fft_spectral_level_demo;' >> fft_spectral_level_demo.dsp
// Mac:
//   faust2caqt fft_spectral_level_demo.dsp
//   open fft_spectral_level_demo.app
// Linux GTK:
//   faust2jack fft_spectral_level_demo.dsp
//   ./fft_spectral_level_demo
// Linux QT:
//   faust2jaqt fft_spectral_level_demo.dsp
//   ./fft_spectral_level_demo
// ```
//-------------------------------------------------------------------
declare fft_spectral_level_demo author "Julius O. Smith III";
declare fft_spectral_level_demo licence "MIT";

fft_spectral_level_demo(N) =  an.rfft_spectral_level(N,tau,dB_offset)
with{
    ctl_group(x)  = hgroup("[1] FFT SPECTRUM ANALYZER CONTROLS", x);
    tau = ctl_group(hslider("[0] Level Averaging Time [unit:ms] [scale:log]
        [tooltip: band-level averaging time in milliseconds]",
        100,1,10000,1)) * 0.001;
    dB_offset = ctl_group(hslider("[1] Level dB Offset [unit:dB]
        [tooltip: Level offset in decibels]",
        50,-50,100,1));
};

//-----------------`(dm.)reverse_echo_demo(nChans)`----------------
// Multichannel echo effect with reverse delays.
//
// #### Usage
//
// ```
// echo 'import("stdfaust.lib");' > reverse_echo_demo.dsp
// echo 'nChans = 3; // Any integer > 1 should work here' >> reverse_echo_demo.dsp
// echo 'process = dm.reverse_echo_demo(nChans);' >> reverse_echo_demo.dsp
// Mac:
//   faust2caqt reverse_echo_demo.dsp
//   open reverse_echo_demo.app
// Linux GTK:
//   faust2jack reverse_echo_demo.dsp
//   ./reverse_echo_demo
// Linux QT:
//   faust2jaqt reverse_echo_demo.dsp
//   ./reverse_echo_demo
// Etc.
// ```
//-------------------------------------------------------------------
declare reverse_echo_demo author "Julius O. Smith III";
declare reverse_echo_demo licence "MIT";

reverse_echo_demo(nChans) =  ef.reverseEchoN(nChans,delMax) : ef.uniformPanToStereo(nChans) 
with {
    delMax = 2^int(nentry("Log2(Delay)",15,5,16,1)); // delay line length
};

//------------------------`(dm.)pospass_demo`------------------------
// Use Positive-Pass Filter pospass() to frequency-shift a sine tone.
// First, a real sinusoid is converted to its analytic-signal form
// using pospass() to filter out its negative frequency component.
// Next, it is multiplied by a modulating complex sinusoid at the
// shifting frequency to create the frequency-shifted result.
// The real and imaginary parts are output to channels 1 & 2.
// For a more interesting frequency-shifting example, check the
// "Use Mic" checkbox to replace the input sinusoid by mic input.
// Note that frequency shifting is not the same as frequency scaling.
// A frequency-shifted harmonic signal is usually not harmonic.
// Very small frequency shifts give interesting chirp effects when
// there is feedback around the frequency shifter.
//
// #### Usage
//
// ```
// echo 'import("stdfaust.lib");' > pospass_demo.dsp
// echo 'process = dm.pospass_demo;' >> pospass_demo.dsp
// Mac:
//   faust2caqt pospass_demo.dsp
//   open pospass_demo.app
// Linux GTK:
//   faust2jack pospass_demo.dsp
//   ./pospass_demo
// Linux QT:
//   faust2jaqt pospass_demo.dsp
//   ./pospass_demo
// Etc.
// ```
//-------------------------------------------------------------------
declare pospass_demo author "Julius O. Smith III";
declare pospass_demo licence "MIT";

pospass_demo(x) = analytic_signal, modulator : si.cmul with {
  N = 6; // pospass filter order
  fc = ma.SR/(2*N); // guard-band for filter roll-off
  octavesShift = hslider("Frequency Shift in octaves away from SR/16",
         -2,-7,3,0.001) : si.smooth(0.999);
  in_select = checkbox("Use Mic");
  sine_tone = os.oscrs(f0);
  f0 = ma.SR/16.0;   // original frequency to be shifted
  fn = f0 * 2.0^octavesShift; // modulated frequency
  df = fn - f0; // frequency-shift as a difference
  input = select2(in_select, sine_tone, x);
  analytic_signal = input : fi.pospass6e(fc); // filter out neg freqs
  //analytic_signal = os.oscrs(f0) : fi.pospass(N,fc); // Butterworth case
  modulator = os.oscrq(df) : si.cconj; // complex modulation sinusoid
  // modulator(n) = exp(sqrt(-1) * 2 * ma.PI * df * n / ma.SR) // if complex ok
};

// end jos section
/************************************************************************
************************************************************************
FAUST library file, GRAME section

Except where noted otherwise, Copyright (C) 2003-2017 by GRAME,
Centre National de Creation Musicale.
----------------------------------------------------------------------
GRAME LICENSE

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as
published by the Free Software Foundation; either version 2.1 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with the GNU C Library; if not, write to the Free
Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
02111-1307 USA.

EXCEPTION TO THE LGPL LICENSE : As a special exception, you may create a
larger FAUST program which directly or indirectly imports this library
file and still distribute the compiled code generated by the FAUST
compiler, or a modified version of this compiled code, under your own
copyright and license. This EXCEPTION TO THE LGPL LICENSE explicitly
grants you the right to freely choose the license for the resulting
compiled code. In particular the resulting compiled code has no obligation
to be LGPL or GPL. For example you are free to choose a commercial or
closed source license or any other license if you decide so.
************************************************************************
************************************************************************/

// TODO: Add GRAME functions here

//########################################################################################
/************************************************************************
FAUST library file, further contributions section

All contributions below should indicate both the contributor and terms
of license.  If no such indication is found, "git blame" will say who
last edited each line, and that person can be emailed to inquire about
license disposition, if their license choice is not already indicated
elsewhere among the libraries.    It is expected that all software will be
released under LGPL, STK-4.3, MIT, BSD, or a similar FOSS license.
************************************************************************/

//-------------------------------`(dm.)exciter`-------------------------------
// Psychoacoustic harmonic exciter, with GUI.
//
// #### Usage
//
// ```
// _ : exciter : _
// ```
//
// #### References
//
// * <https://secure.aes.org/forum/pubs/ebriefs/?elib=16939>
// * <https://www.researchgate.net/publication/258333577_Modeling_the_Harmonic_Exciter>
//-------------------------------------------------------------------------------------
declare exciter author "PPriyanka Shekar and Julius O. Smith III";
declare exciter licence "STK-4.3";

//-------------------------------------------------------------------------------------
exciter = _ <: (fi.highpass(2, fc) : compressor : pregain : harmonicCreator :
    postgain), _ : balance
with{
    // TODO: rewrite to use the standard compressor from compressors.lib
    compressor = ba.bypass1(cbp,compressorMono)
    with{
        comp_group(x) = vgroup("COMPRESSOR  [tooltip: Reference:
            http://en.wikipedia.org/wiki/Dynamic_range_compression]", x);

    meter_group(x) = comp_group(hgroup("[0]", x));
    knob_group(x) = comp_group(hgroup("[1]", x));

    cbp = meter_group(checkbox("[0] Bypass  [tooltip: When this is checked,
        the compressor has no effect]"));

    gainview = co.compression_gain_mono(ratio,threshold,attack,release) : ba.linear2db
        : meter_group(hbargraph("[1] Compressor Gain [unit:dB] [tooltip: Current gain
        of the compressor in dB]",-50,+10));

    displaygain = _ <: _,abs : _,gainview : attach;

    compressorMono = displaygain(co.compressor_mono(ratio,threshold,attack,release));

    ctl_group(x) = knob_group(hgroup("[3] Compression Control", x));

    ratio = ctl_group(hslider("[0] Ratio [style:knob]  [tooltip: A compression Ratio
    of N means that for each N dB increase in input signal level above Threshold, the
    output level goes up 1 dB]", 5, 1, 20, 0.1));

    threshold = ctl_group(hslider("[1] Threshold [unit:dB] [style:knob] [tooltip:
    When the signal level exceeds the Threshold (in dB), its level is compressed
    according to the Ratio]", -30, -100, 10, 0.1));

    env_group(x) = knob_group(hgroup("[4] Compression Response", x));

    attack = env_group(hslider("[1] Attack [unit:ms] [style:knob]  [tooltip:
    Time constant in ms (1/e smoothing time) for the compression gain to approach
    (exponentially) a new lower target level (the compression `kicking in')]",
    50, 0, 500, 0.1)) : *(0.001) : max(1/ma.SR);

    release = env_group(hslider("[2] Release [unit:ms] [style: knob]  [tooltip:
    Time constant in ms (1/e smoothing time) for the compression gain to approach
    (exponentially) a new higher target level (the compression 'releasing')]",
    500, 0, 1000, 0.1)) : *(0.001) : max(1/ma.SR);
    };

    //Exciter GUI controls
    ex_group(x) = hgroup("EXCITER  [tooltip: Reference: Patent US4150253 A]", x);

    //Highpass - selectable cutoff frequency
    fc = ex_group(hslider("[0] Cutoff Frequency [unit:Hz] [style:knob] [scale:log]
        [tooltip: Cutoff frequency for highpassed components to be excited]",
    5000, 1000, 10000, 100));

    //Pre-distortion gain - selectable percentage of harmonics
    ph = ex_group(hslider("[1] Harmonics [unit:percent] [style:knob] [tooltip:
        Percentage of harmonics generated]", 20, ma.EPSILON, 200, 1)) / 100;
    pregain = * (ph);

    // TODO: same thing: why doesn't this use cubicnl?
    //Asymmetric cubic soft clipper
    harmonicCreator(x) = x <: cubDist1, cubDist2, cubDist3 :> _;
    cubDist1(x) = (x < 0) * x;
    cubDist2(x) = (x >= 0) * (x <= 1) * (x - x ^ 3 / 3);
    cubDist3(x) = (x > 1) * 2/3;

    //Post-distortion gain - undoes effect of pre-gain
    postgain = * (1/ph);

    //Balance - selectable dry/wet mix
    ml = ex_group(hslider("[2] Mix [style:knob] [tooltip: Dry/Wet mix of original signal
        to excited signal]", 0.5, 0, 1, 0.01));
    balance = (_ * ml), (_ * (1.0 - ml)) :> _;
};


//----------------------------`(dm.)vocoder_demo`-------------------------
// Use example of the vocoder function where an impulse train is used
// as excitation.
//
// #### Usage
//
// ```
// _ : vocoder_demo : _
// ```
//------------------------------------------------------------
declare vocoder_demo author "Romain Michon";
declare vocoder_demo licence "LGPL";

vocoder_demo = hgroup("My Vocoder",_,os.lf_imptrain(freq)*gain :
    ve.vocoder(bands,att,rel,BWRatio) <: _,_)
with{
    bands = 32;
    vocoderGroup(x) = vgroup("Vocoder",x);
    att = vocoderGroup(hslider("[0] Attack [style:knob] [tooltip: Attack time in seconds]",
        5,0.1,100,0.1)*0.001);
    rel = vocoderGroup(hslider("[1] Release [style:knob] [tooltip: Release time in seconds]",
        5,0.1,100,0.1)*0.001);
    BWRatio = vocoderGroup(hslider("[2] BW [style:knob] [tooltip: Coefficient to adjust the
        bandwidth of each band]",0.5,0.1,2,0.001));
    excitGroup(x) = vgroup("Excitation",x);
    freq = excitGroup(hslider("[0] Freq [style:knob]",330,50,2000,0.1));
    gain = excitGroup(vslider("[1] Gain",0.5,0,1,0.01) : si.smoo);
};

//-----------------`(dm.)colored_noise_demo`--------------------
// A coloured noise signal generator.
//
// #### Usage
//
// ```
// colored_noise_demo : _
// ```
//
//-------------------------------------------------
declare colored_noise author "Constantinos Odysseas Economou";
declare colored_noise license "MIT";

colored_noise_demo = no.colored_noise(N,alpha) : *(ampdb) : *(gate)
with {
    N = 12;

    alpha = hslider("[0] Alpha [style:knob] [tooltip: Spectral roll-off factor]", 0.0, -1.0, 1.0, 0.001) : si.smoo;
    ampdb = hslider("[1] Amplitude [unit:dB] [style:knob] [tooltip: Noise amplitude]", -20, -120, 10, 0.1) : ba.db2linear : si.smoo;
    gate = checkbox("[2] Gate");
};

// end further contributions section
